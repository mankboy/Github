#!/usr/bin/env python3
# LMS_batch_word_to_api.py
# Process Word documents with questions and send to AnythingLLM API

import os
import re
import json
import time
import logging
import tkinter as tk
from tkinter import filedialog, ttk, messagebox, scrolledtext
import threading
import queue
import requests
import sqlite3
import hashlib
from docx import Document
from docx.shared import Pt, RGBColor, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH
import sys
import subprocess
import matplotlib
matplotlib.use('TkAgg')
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
import platform
import logging.handlers
import random
import shutil

# Version information
VERSION = "0.6.0"  # Added queue management and API diagnostics

# Configure logging for Cursor AI
CURSOR_LOG_FILE = os.path.expanduser("~/lms_batch_cursor_log.json")

# Create a custom formatter that outputs JSON for Cursor AI
class JsonFormatter(logging.Formatter):
    def format(self, record):
        log_record = {
            "timestamp": self.formatTime(record, "%Y-%m-%d %H:%M:%S"),
            "level": record.levelname,
            "type": getattr(record, 'event_type', 'general'),
            "message": record.getMessage(),
            "data": getattr(record, 'data', {})
        }
        return json.dumps(log_record)

# Set up Cursor AI logger
cursor_logger = logging.getLogger('cursor_ai')
cursor_logger.setLevel(logging.INFO)
cursor_logger.propagate = False  # Don't propagate to parent

try:
    # Create a rotating file handler for the Cursor AI logger
    cursor_handler = logging.handlers.RotatingFileHandler(
        CURSOR_LOG_FILE, maxBytes=10*1024*1024, backupCount=5, mode='a'
    )
    cursor_handler.setFormatter(JsonFormatter())
    cursor_logger.addHandler(cursor_handler)
    
    # Log startup information
    def log_for_cursor(event_type, message, data=None):
        """Log an event in a structured format for Cursor AI."""
        if data is None:
            data = {}
        try:
            cursor_logger.info(message, extra={"event_type": event_type, "data": data})
        except Exception as e:
            print(f"Error logging to Cursor AI: {str(e)}")
    
    log_for_cursor("app_start", f"Application started", {"version": VERSION})
except Exception as e:
    print(f"Could not initialize Cursor AI logging: {str(e)}")

# Configure standard logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
logger = logging.getLogger('LMS_batch')

# API request status tracking
API_REQUESTS = {
    'total_sent': 0,
    'successful': 0,
    'failed': 0,
    'last_error': None,
    'last_request_time': None,
    'last_response_time': None
}

# AnythingLLM API endpoint
API_ENDPOINT = "http://127.0.0.1:1234/v1/chat/completions"  # Updated to use local endpoint
API_KEY = "M21HB7F-4MP48RV-JRYA18Y-F03BN82"  # Hard-coded API key

# Config file for saving settings
CONFIG_FILE = os.path.expanduser("~/lms_batch_config.json")

# Database file for persistence
DB_FILE = os.path.expanduser("~/lms_batch_database.sqlite")

# GPU monitoring data
GPU_DATA = {
    'times': [],
    'utilization': [],
    'max_points': 60  # 1 minute of data at 1 sample per second
}

def get_gpu_utilization():
    """Get GPU utilization based on platform"""
    try:
        if platform.system() == "Darwin":  # macOS
            # For M1/M2/M3 Macs - use a simulated approach with timeout protection
            try:
                logger.debug("Using simulated GPU activity on macOS")  # Changed from INFO to DEBUG
                # Don't try powermetrics which can hang - just use simulation
                if hasattr(get_gpu_utilization, 'last_value'):
                    # Vary the previous value slightly for a more realistic graph
                    variation = random.randint(-10, 10)
                    new_value = max(10, min(90, get_gpu_utilization.last_value + variation))
                else:
                    # Initial random value
                    new_value = random.randint(30, 70)
                
                # Store for next time
                get_gpu_utilization.last_value = new_value
                return new_value
            except Exception as e:
                logger.error(f"GPU simulation error: {str(e)}")
                return 0
                
        elif platform.system() == "Windows":
            # For Windows with NVIDIA GPUs
            try:
                logger.info("Attempting to get GPU utilization on Windows")
                # Add timeout to prevent hanging
                result = subprocess.run(['nvidia-smi', '--query-gpu=utilization.gpu', '--format=csv,noheader,nounits'], 
                                      capture_output=True, text=True, timeout=2)
                utilization = int(result.stdout.strip())
                logger.info(f"Found GPU utilization via nvidia-smi: {utilization}%")
                return utilization
            except (subprocess.SubprocessError, subprocess.TimeoutExpired, ValueError) as e:
                logger.error(f"Windows GPU detection failed: {str(e)}")
                return 0
                
        elif platform.system() == "Linux":
            # For Linux with NVIDIA GPUs
            try:
                logger.info("Attempting to get GPU utilization on Linux")
                # Add timeout to prevent hanging
                result = subprocess.run(['nvidia-smi', '--query-gpu=utilization.gpu', '--format=csv,noheader,nounits'], 
                                      capture_output=True, text=True, timeout=2)
                utilization = int(result.stdout.strip())
                logger.info(f"Found GPU utilization via nvidia-smi: {utilization}%")
                return utilization
            except (subprocess.SubprocessError, subprocess.TimeoutExpired, ValueError) as e:
                logger.error(f"Linux GPU detection failed: {str(e)}")
                return 0
                
        logger.warning(f"No GPU detection method available for platform: {platform.system()}")
        return 0
    except Exception as e:
        logger.error(f"Error in GPU utilization detection: {str(e)}")
        return 0

def load_config():
    """Load configuration from file"""
    if os.path.exists(CONFIG_FILE):
        try:
            with open(CONFIG_FILE, 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Error loading config: {str(e)}")
    
    # Default config
    return {
        "last_input_dir": os.path.expanduser("~"),
        "last_output_dir": os.path.expanduser("~"),
        "api_endpoint": API_ENDPOINT,
        "api_key": "",  # Separate API key field
        "model": "local-model"
    }

def save_config(config):
    """Save configuration to file"""
    try:
        with open(CONFIG_FILE, 'w') as f:
            json.dump(config, f, indent=2)
    except Exception as e:
        logger.error(f"Error saving config: {str(e)}")

def init_database():
    """Initialize the SQLite database for storing processed questions"""
    try:
        conn = sqlite3.connect(DB_FILE)
        cursor = conn.cursor()
        
        # Create tables if they don't exist
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS questions (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            question_hash TEXT UNIQUE,
            question_text TEXT,
            source_file TEXT,
            processed_date TEXT,
            status TEXT DEFAULT 'pending'
        )
        ''')
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS options (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            question_id INTEGER,
            letter TEXT,
            text TEXT,
            FOREIGN KEY (question_id) REFERENCES questions(id)
        )
        ''')
        
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS answers (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            question_id INTEGER,
            answer TEXT,
            reasoning TEXT,
            citations TEXT,
            processed_date TEXT,
            FOREIGN KEY (question_id) REFERENCES questions(id)
        )
        ''')
        
        # Check if we need to add the status column to an existing table
        cursor.execute("PRAGMA table_info(questions)")
        columns = cursor.fetchall()
        column_names = [column[1] for column in columns]
        
        if 'status' not in column_names:
            logger.info("Adding status column to questions table")
            cursor.execute("ALTER TABLE questions ADD COLUMN status TEXT DEFAULT 'pending'")
            
        conn.commit()
        conn.close()
        logger.info(f"Database initialized at {DB_FILE}")
        return True
    except Exception as e:
        logger.exception(f"Error initializing database: {str(e)}")
        return False

def hash_question(question_text, options):
    """Create a unique hash for a question and its options"""
    content = question_text
    for opt in sorted(options, key=lambda x: x['letter']):
        content += opt['letter'] + opt['text']
    return hashlib.md5(content.encode('utf-8')).hexdigest()

class DocumentReader:
    def __init__(self, doc_path):
        """Initialize with the document path"""
        logger.info(f"Opening document: {doc_path}")
        self.doc = Document(doc_path)
        self.paragraphs = self.doc.paragraphs
        self.total_paragraphs = len(self.paragraphs)
        self.current_position = 0
        self.debug_mode = True  # Enable detailed logging for question extraction
        
        # Pattern to identify question and options - made more flexible
        self.question_pattern = re.compile(r'^(?:\d+[\.\)]\s*)?(.+)$')
        self.option_pattern = re.compile(r'^([A-D])[\.\)\s:-]+\s*(.+)$')
        
        # Keywords that indicate explanatory text, not actual questions
        self.explanation_keywords = [
            "explanation:", "answer:", "correct answer:", "incorrect:", "why other answers", 
            "solution:", "justification:", "rationale:", "feedback:"
        ]
        
        # Keywords that suggest an actual question is being asked - expanded
        self.question_indicators = [
            "?", "which", "what", "how", "why", "when", "where", "who", "choose", "select", 
            "identify", "determine", "calculate", "evaluate", "describe", "explain", "list",
            "true or false", "correct", "incorrect", "best", "most", "least", "appropriate",
            "example", "following", "statements", "consider", "according", "defined"
        ]
    
    def get_next_question(self):
        """
        Extract the next valid question from the document
        Returns a dictionary with question info or None if no more questions
        """
        current_question = None
        current_options = []
        
        # Looking for options flag
        collecting_options = False
        question_start_position = 0
        
        # Start from the current position
        while self.current_position < self.total_paragraphs:
            text = self.paragraphs[self.current_position].text.strip()
            current_pos = self.current_position
            self.current_position += 1
            
            if not text:
                continue
                
            # Log the current paragraph text if debug mode is enabled
            if self.debug_mode:
                logger.info(f"Examining paragraph {current_pos}: '{text[:50]}...'")
                
            # Check if this is option text
            option_match = self.option_pattern.match(text)
            if option_match:
                # This is an option
                option_letter = option_match.group(1)
                option_text = option_match.group(2).strip()
                
                # If we're not already collecting options but find one, and we don't have a question yet,
                # look back a few paragraphs to find a potential question
                if not collecting_options and not current_question:
                    # Look back up to 3 paragraphs to find a potential question
                    look_back = min(3, current_pos)
                    for i in range(1, look_back + 1):
                        prev_text = self.paragraphs[current_pos - i].text.strip()
                        if prev_text and not self.option_pattern.match(prev_text):
                            # This could be our question
                            question_match = self.question_pattern.match(prev_text)
                            if question_match:
                                potential_question = question_match.group(1).strip()
                                if self.is_valid_question(potential_question):
                                    current_question = potential_question
                                    question_start_position = current_pos - i
                                    collecting_options = True
                                    logger.info(f"Found potential question by looking back: '{potential_question[:50]}...'")
                                    break
                
                # Now add the option if we have a question
                if current_question:
                    collecting_options = True
                    
                    # Skip options with very short text
                    if len(option_text) < 2:
                        logger.warning(f"Skipping too short option {option_letter}: '{option_text}'")
                        continue
                        
                    # Handle duplicate options by updating instead of skipping
                    existing_option_index = -1
                    for i, opt in enumerate(current_options):
                        if opt['letter'] == option_letter:
                            existing_option_index = i
                            break
                            
                    if existing_option_index >= 0:
                        logger.warning(f"Updating duplicate option {option_letter}")
                        current_options[existing_option_index]['text'] = option_text
                    else:
                        current_options.append({
                            'letter': option_letter,
                            'text': option_text
                        })
                        logger.info(f"Extracted option {option_letter}: {option_text[:30]}...")
            else:
                # Not an option - check if it's a new question
                
                # If we're collecting options and have enough, check if it's complete
                if collecting_options and len(current_options) >= 2:
                    # Check if we have reasonable options for a complete question
                    if self.validate_question_options(current_question, current_options):
                        logger.info(f"Completed question with {len(current_options)} options: '{current_question[:50]}...'")
                        # Reposition to process this paragraph again if it's a new question
                        self.current_position = current_pos
                        return {
                            'question': current_question,
                            'options': current_options.copy(),
                            'position': question_start_position
                        }
                
                # Check if this is a new question
                question_match = self.question_pattern.match(text)
                if question_match:
                    potential_question = question_match.group(1).strip()
                    
                    # If we're already collecting for a current question, this new text
                    # may indicate the end of options and start of a new question
                    if collecting_options and len(current_options) >= 2:
                        # Check if we have a valid question before starting a new one
                        if self.validate_question_options(current_question, current_options):
                            logger.info(f"Found new question while processing options, returning completed question: '{current_question[:50]}...'")
                            # Reposition to process this paragraph again
                            self.current_position = current_pos
                            return {
                                'question': current_question,
                                'options': current_options.copy(),
                                'position': question_start_position
                            }
                    
                    # Check if the new text is a valid question
                    if self.is_valid_question(potential_question):
                        current_question = potential_question
                        question_start_position = current_pos
                        current_options = []
                        collecting_options = False
                        logger.info(f"Started new question: '{potential_question[:50]}...'")
                    else:
                        if self.debug_mode:
                            logger.warning(f"Invalid question text: '{potential_question[:50]}...'")
        
        # Check if we have a valid question at the end of the document
        if current_question and len(current_options) >= 2:
            if self.validate_question_options(current_question, current_options):
                logger.info(f"Returning final question in document: '{current_question[:50]}...'")
                return {
                    'question': current_question,
                    'options': current_options.copy(),
                    'position': question_start_position
                }
        
        # No more valid questions
        logger.info("No more valid questions found in document")
        return None
    
    def is_valid_question(self, text):
        """Check if text is likely a valid question"""
        # Skip very short text
        if len(text) < 10:
            return False
            
        # Skip phrases that are likely explanations - expanded list with more specific patterns
        explanation_keywords = [
            "explanation:", "answer:", "correct answer:", "incorrect:", "why other answers", 
            "solution:", "justification:", "rationale:", "feedback:", "reasoning:", 
            "hence,", "therefore,", "thus,", "consequently,", "as a result,",
            "this is because", "this is due to", "this is why", "because of this",
            "incorrect because", "correct because", "is incorrect since", "is correct since",
            "option a is", "option b is", "option c is", "option d is",
            "a is", "b is", "c is", "d is", "a)", "b)", "c)", "d)"
        ]
        
        # Check for explanation keywords with more robust pattern matching
        for keyword in explanation_keywords:
            pattern = r'\b' + re.escape(keyword.lower()) + r'\b'
            if re.search(pattern, text.lower()):
                if self.debug_mode:
                    logger.info(f"Rejected as explanation due to keyword: '{keyword}'")
                return False
            
        # Check if it contains question indicators
        has_indicator = False
        
        # Question mark is a strong indicator
        if '?' in text:
            has_indicator = True
        else:
            # Check for other question indicator words
            for indicator in self.question_indicators:
                pattern = r'\b' + re.escape(indicator.lower()) + r'\b'
                if re.search(pattern, text.lower()):
                    has_indicator = True
                    break
                    
        # Accept statements ending with colon as potential question stems
        if not has_indicator and text.endswith(':'):
            has_indicator = True
            
        # Make longer texts more likely to be accepted as questions
        if len(text) > 40 and not has_indicator:
            # For longer texts, be more lenient
            has_indicator = True
            
        return has_indicator
    
    def validate_question_options(self, question, options):
        """Validate a question and its options"""
        if not question or len(options) < 2:
            return False
            
        # Get option letters
        option_letters = sorted([opt['letter'] for opt in options])
        
        # Must have at least options A and B
        if 'A' not in option_letters:
            return False
            
        # Check if options are mostly sequential
        is_mostly_sequential = True
        expected_letters = [chr(ord('A') + i) for i in range(len(option_letters))]
        missing_letters = set(expected_letters) - set(option_letters)
        
        # Allow missing at most one letter in the sequence
        if len(missing_letters) > 1:
            is_mostly_sequential = False
            
        # Check option text length - relaxed validation
        for opt in options:
            # Skip options that are just single letters or very short
            if len(opt['text']) < 2:
                return False
                
        # Require at least 2 options and mostly sequential option letters
        return len(options) >= 2 and is_mostly_sequential

class WordDocProcessor:
    def __init__(self, master):
        self.master = master
        master.title(f"AnythingLLM Word Batch Processor v{VERSION}")
        master.geometry("800x600")
        
        # Load saved configuration
        self.config = load_config()
        
        # Initialize database
        init_database()
        
        # API activity tracking
        self.active_api_requests = 0
        self.api_activity_indicator = None
        self.api_status_var = tk.StringVar(value="API: Idle")
        
        # GPU monitoring variables
        self.gpu_monitoring = False
        self.gpu_monitor_thread = None
        self.gpu_canvas = None
        self.gpu_figure = None
        
        # Set up the UI components
        self.create_widgets()
        
        # Processing variables
        self.input_file = ""
        self.output_file = ""
        self.doc_reader = None
        self.results = []
        self.current_question = None
        self.processing_thread = None
        self.is_processing = False
        self.cached_questions = {}  # Cache for database lookups
        
        # Queue for API processing
        self.api_queue = queue.Queue()
        self.pending_questions = []  # Store questions waiting to be sent to API
        self.api_threads = []
        self.max_api_threads = 3  # Maximum parallel API requests
        
        # Queue management
        self.queue_window = None
        
        # Set up console logging to text widget
        self.setup_text_handler()
        
        # Load last used file paths
        self.restore_last_file_paths()
        
        # Set up periodic check for API results
        self.check_api_results()
        
        # Load the cached questions from database
        self.load_cached_questions()
        
        # Start GPU monitoring
        self.start_gpu_monitoring()
    
    def restore_last_file_paths(self):
        """Restore the last used file paths from config"""
        # Check if we have last used file paths
        if "last_input_file" in self.config:
            input_files = self.config["last_input_file"].split(";")
            
            if input_files and all(os.path.exists(f) for f in input_files):
                # Store the full paths for processing
                self.input_file = self.config["last_input_file"]
                
                # Set directory path (use the directory of the first file)
                directory_path = os.path.dirname(input_files[0])
                self.input_path_var.set(directory_path)
                
                # Set filename display similar to browse_input
                if len(input_files) == 1:
                    # Single file - show the filename
                    filename_display = os.path.basename(input_files[0])
                else:
                    # Multiple files - show count and first filename
                    filename_display = f"{os.path.basename(input_files[0])} and {len(input_files)-1} more files"
                
                # Update the filename entry
                self.input_filename_var.set(filename_display)
                
                # Configure entry states and colors
                self.input_filename_entry.config(state="normal")
                self.input_filename_entry.delete(0, tk.END)
                self.input_filename_entry.insert(0, filename_display)
                self.input_filename_entry.config(state="readonly", fg="black", bg="#ffffff", readonlybackground="#f0f0f0")
                
                self.input_path_entry.config(state="normal")
                self.input_path_entry.delete(0, tk.END)
                self.input_path_entry.insert(0, directory_path)
                self.input_path_entry.config(state="readonly", fg="black", bg="#ffffff", readonlybackground="#f0f0f0")
                
                logger.info(f"Restored last input file: {self.input_file}")
            
        if "last_output_file" in self.config:
            output_file = self.config["last_output_file"]
            self.output_file = output_file
            
            # Extract directory path and filename
            output_dir = os.path.dirname(output_file)
            output_filename = os.path.basename(output_file)
            
            # Update the output fields
            self.output_filename_var.set(output_filename)
            self.output_path_var.set(output_dir)
            
            # Configure entry states
            self.output_path_entry.config(state="normal")
            self.output_path_entry.delete(0, tk.END)
            self.output_path_entry.insert(0, output_dir)
            self.output_path_entry.config(state="readonly", fg="black", bg="#ffffff", readonlybackground="#f0f0f0")
            
            logger.info(f"Restored last output file: {self.output_file}")
    
    def setup_text_handler(self):
        """Configure logging to also write to the console text widget"""
        class TextHandler(logging.Handler):
            def __init__(self, text_widget):
                logging.Handler.__init__(self)
                self.text_widget = text_widget
                
            def emit(self, record):
                msg = self.format(record)
                def append():
                    self.text_widget.configure(state='normal')
                    self.text_widget.insert(tk.END, msg + '\n')
                    self.text_widget.see(tk.END)
                    self.text_widget.configure(state='disabled')
                # Schedule append to be called in the GUI thread
                self.text_widget.after(0, append)
        
        text_handler = TextHandler(self.console_text)
        text_handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logger.addHandler(text_handler)
    
    def create_widgets(self):
        """Create the GUI elements"""
        # Frame for version info
        version_frame = tk.Frame(self.master, padx=10, pady=5)
        version_frame.pack(fill=tk.X)
        
        # Version label - doubled size
        version_label = tk.Label(version_frame, text=f"Version: {VERSION}", font=("Helvetica", 18, "bold"))
        version_label.pack(side=tk.RIGHT)
        
        # Add a label for Cursor AI log file
        cursor_log_frame = tk.Frame(version_frame)
        cursor_log_frame.pack(side=tk.LEFT)
        cursor_log_label = tk.Label(cursor_log_frame, text="Cursor AI Logging Enabled", font=("Helvetica", 8))
        cursor_log_label.pack(side=tk.LEFT)
        cursor_log_button = tk.Button(cursor_log_frame, text="Info", font=("Helvetica", 8), 
                                    command=self.show_cursor_log_info, padx=2, pady=0, bd=1)
        cursor_log_button.pack(side=tk.LEFT, padx=5)
        
        # Frame for file selection
        file_frame = tk.Frame(self.master, padx=10, pady=10)
        file_frame.pack(fill=tk.X)
        
        # Input file selection section
        input_section = tk.LabelFrame(file_frame, text="Input Word Document(s)", padx=5, pady=5)
        input_section.grid(row=0, column=0, columnspan=3, sticky="we", pady=5)
        file_frame.grid_columnconfigure(1, weight=1)  # Make the middle column expandable
        
        # Input filename display
        tk.Label(input_section, text="Filename(s):").grid(row=0, column=0, sticky="w")
        self.input_filename_var = tk.StringVar()
        self.input_filename_entry = tk.Entry(input_section, textvariable=self.input_filename_var, width=50, readonlybackground="#f0f0f0")
        self.input_filename_entry.grid(row=0, column=1, padx=5, sticky="we")
        
        # Input path display
        tk.Label(input_section, text="Path:").grid(row=1, column=0, sticky="w", pady=5)
        self.input_path_var = tk.StringVar()
        self.input_path_entry = tk.Entry(input_section, textvariable=self.input_path_var, width=50, readonlybackground="#f0f0f0")
        self.input_path_entry.grid(row=1, column=1, padx=5, pady=5, sticky="we")
        
        # Input browse button
        tk.Button(input_section, text="Browse...", command=self.browse_input).grid(row=0, column=2, rowspan=2, padx=5, pady=5)
        
        # Output file selection section
        output_section = tk.LabelFrame(file_frame, text="Output Word Document", padx=5, pady=5)
        output_section.grid(row=1, column=0, columnspan=3, sticky="we", pady=5)
        
        # Output filename display
        tk.Label(output_section, text="Filename:").grid(row=0, column=0, sticky="w")
        self.output_filename_var = tk.StringVar()
        tk.Entry(output_section, textvariable=self.output_filename_var, width=50).grid(row=0, column=1, padx=5, sticky="we")
        
        # Output path display
        tk.Label(output_section, text="Path:").grid(row=1, column=0, sticky="w", pady=5)
        self.output_path_var = tk.StringVar()
        self.output_path_entry = tk.Entry(output_section, textvariable=self.output_path_var, width=50, readonlybackground="#f0f0f0")
        self.output_path_entry.grid(row=1, column=1, padx=5, pady=5, sticky="we")
        
        # Output browse button
        tk.Button(output_section, text="Browse...", command=self.browse_output).grid(row=0, column=2, rowspan=2, padx=5, pady=5)
        
        # Configure column weights for sections to make them expand properly
        input_section.grid_columnconfigure(1, weight=1)
        output_section.grid_columnconfigure(1, weight=1)
        
        # API settings frame
        api_frame = tk.Frame(self.master, padx=10, pady=5)
        api_frame.pack(fill=tk.X)
        api_frame.grid_columnconfigure(1, weight=1)  # Make middle column expandable
        api_frame.grid_columnconfigure(2, weight=0)  # Right column fixed size
        
        # Left side - API settings
        # API Endpoint
        tk.Label(api_frame, text="API Endpoint:").grid(row=0, column=0, sticky="w")
        self.api_endpoint_var = tk.StringVar(value=self.config.get("api_endpoint", API_ENDPOINT))
        tk.Entry(api_frame, textvariable=self.api_endpoint_var, width=50).grid(row=0, column=1, padx=5, sticky="we")
        
        # Model selection (moved up to row 1)
        tk.Label(api_frame, text="Model:").grid(row=1, column=0, sticky="w", pady=5)
        self.model_var = tk.StringVar(value=self.config.get("model", "gpt-4"))
        tk.Entry(api_frame, textvariable=self.model_var, width=30).grid(row=1, column=1, padx=5, pady=5, sticky="w")
        
        # Add timeout setting (moved up to row 2)
        tk.Label(api_frame, text="API Timeout (sec):").grid(row=2, column=0, sticky="w", pady=5)
        self.timeout_var = tk.StringVar(value=self.config.get("api_timeout", "90"))  # Changed default from 60 to 90
        timeout_entry = tk.Entry(api_frame, textvariable=self.timeout_var, width=10)
        timeout_entry.grid(row=2, column=1, padx=5, pady=5, sticky="w")
        tk.Label(api_frame, text="(Increase for complex questions or slower models)").grid(row=2, column=1, padx=120, pady=5, sticky="w")
        
        # Right side - GPU and Database stats
        # Create a frame for the right side components
        right_frame = tk.Frame(api_frame, padx=5)
        right_frame.grid(row=0, column=2, rowspan=3, sticky="ne", padx=10)
        
        # GPU Utilization section - now in the right frame
        gpu_section = tk.Frame(right_frame)
        gpu_section.pack(fill=tk.X, pady=5)
        
        tk.Label(gpu_section, text="GPU Utilization:", font=("Helvetica", 10, "bold")).pack(side=tk.LEFT, anchor=tk.W)
        
        # Frame for the matplotlib chart - fixed width and increased height
        chart_frame = tk.Frame(gpu_section, height=90, width=400)  # Increased height from 30 to 90 (3x taller)
        chart_frame.pack(side=tk.LEFT, padx=5)
        chart_frame.pack_propagate(False)  # Prevent the frame from resizing to fit its contents
        
        # Create the matplotlib figure - wider and taller
        self.gpu_figure = plt.Figure(figsize=(2.0, 2.4), dpi=100)  # Increased height from 0.8 to 2.4 (3x taller)
        self.gpu_canvas = FigureCanvasTkAgg(self.gpu_figure, chart_frame)
        self.gpu_canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Configure the plot
        self.ax = self.gpu_figure.add_subplot(111)
        self.ax.set_ylim(0, 100)
        self.ax.set_xlim(0, GPU_DATA['max_points'])
        self.ax.set_ylabel('% Util')
        # Remove x labels to save space
        self.ax.set_xticks([])
        # Add grid lines
        self.ax.grid(True, linestyle='--', alpha=0.7)
        # Create empty line
        self.line, = self.ax.plot([], [], lw=2, color='green')
        self.gpu_figure.tight_layout()
        
        # Database stats section - also in the right frame
        db_section = tk.Frame(right_frame)
        db_section.pack(fill=tk.X, pady=5)
        
        self.db_stats_var = tk.StringVar(value="Database: 0 cached answers")
        tk.Label(db_section, textvariable=self.db_stats_var).grid(row=0, column=0, sticky="w")
        
        # API activity indicator
        api_indicator_frame = tk.Frame(db_section, width=20, height=20)
        api_indicator_frame.grid(row=0, column=3, padx=5)
        self.api_activity_indicator = tk.Canvas(api_indicator_frame, width=20, height=20, 
                                            highlightthickness=0, bg=self.master.cget('bg'))
        self.api_activity_indicator.pack()
        self.draw_api_indicator("idle")
        
        # API status label
        self.api_status_var = tk.StringVar(value="API: Idle")
        tk.Label(db_section, textvariable=self.api_status_var).grid(row=0, column=4, sticky="w", padx=5)
        
        # Clear cache button
        self.clear_cache_button = tk.Button(db_section, text="Clear Cache", command=self.clear_cache, bg="#ffeeee")
        self.clear_cache_button.grid(row=0, column=1, padx=5, sticky="e")
        
        # Save progress button
        self.save_progress_button = tk.Button(db_section, text="Save Progress", command=self.save_progress, bg="#eeffee", state=tk.DISABLED)
        self.save_progress_button.grid(row=0, column=2, padx=5, sticky="e")
        
        # Question preview frame - new section for interactive mode
        question_frame = tk.Frame(self.master, padx=10, pady=5)
        question_frame.pack(fill=tk.BOTH, expand=True)
        
        tk.Label(question_frame, text="Current Question:", font=("Helvetica", 10, "bold")).pack(anchor=tk.W)
        
        # Create a scrolled text widget for question preview
        self.question_text = scrolledtext.ScrolledText(question_frame, height=10, wrap=tk.WORD, font=("Helvetica", 14))
        self.question_text.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.question_text.configure(state='disabled')
        
        # Add tag configuration for headings
        self.question_text.tag_configure("heading", font=("Helvetica", 16, "bold"))
        
        # Button frame for question actions
        action_frame = tk.Frame(self.master, padx=10, pady=5)
        action_frame.pack(fill=tk.X)
        
        self.start_button = tk.Button(action_frame, text="Start Processing", command=self.start_processing, width=15)
        self.start_button.pack(side=tk.LEFT, padx=5)
        
        self.approve_button = tk.Button(action_frame, text="Approve (A)", command=self.approve_question, width=10, state=tk.DISABLED)
        self.approve_button.pack(side=tk.LEFT, padx=5)
        
        self.skip_button = tk.Button(action_frame, text="Skip (S)", command=self.skip_question, width=15, state=tk.DISABLED)
        self.skip_button.pack(side=tk.LEFT, padx=5)
        
        # Add manage queue button
        self.manage_queue_button = tk.Button(action_frame, text="Manage Queue", command=self.open_queue_manager, width=15, state=tk.DISABLED)
        self.manage_queue_button.pack(side=tk.LEFT, padx=5)
        
        self.stop_button = tk.Button(action_frame, text="Stop", command=self.stop_processing, width=10, state=tk.DISABLED)
        self.stop_button.pack(side=tk.LEFT, padx=5)
        
        # Add test API button
        self.test_api_button = tk.Button(action_frame, text="Test API", command=self.test_api_connection, bg="#e0e0ff", width=10)
        self.test_api_button.pack(side=tk.LEFT, padx=5)
        
        # Add RAG test button
        self.test_rag_button = tk.Button(action_frame, text="Test RAG", command=self.test_rag_capabilities, bg="#e0ffff", width=10)
        self.test_rag_button.pack(side=tk.LEFT, padx=5)
        
        # Add Quit button
        self.quit_button = tk.Button(action_frame, text="Quit", command=self.quit_application, width=10, bg="#ffcccc")
        self.quit_button.pack(side=tk.RIGHT, padx=5)
        
        # Progress frame
        progress_frame = tk.Frame(self.master, padx=10, pady=5)
        progress_frame.pack(fill=tk.X)
        
        tk.Label(progress_frame, text="Progress:").pack(anchor=tk.W)
        self.progress_var = tk.StringVar(value="Ready")
        tk.Label(progress_frame, textvariable=self.progress_var).pack(anchor=tk.W)
        
        self.progress_bar = ttk.Progressbar(progress_frame, orient=tk.HORIZONTAL, length=100, mode='determinate')
        self.progress_bar.pack(fill=tk.X, pady=5)
        
        # Console output (logging) - reduced height for question space
        console_frame = tk.Frame(self.master, padx=10, pady=5)
        console_frame.pack(fill=tk.BOTH, expand=False)  # Not expanding
        
        tk.Label(console_frame, text="Console Output:").pack(anchor=tk.W)
        
        # Create a scrolled text widget for console output
        self.console_text = scrolledtext.ScrolledText(console_frame, height=6, wrap=tk.WORD)
        self.console_text.pack(fill=tk.BOTH, expand=False, padx=5, pady=5)
        self.console_text.configure(state='disabled')
        
        # Configure tags for different message types
        self.console_text.tag_configure("info", foreground="black")
        self.console_text.tag_configure("error", foreground="red")
        self.console_text.tag_configure("api", foreground="blue")
        
        # Set up keyboard shortcuts for approve and skip
        self.master.bind('<a>', lambda event: self.approve_if_enabled())
        self.master.bind('<A>', lambda event: self.approve_if_enabled())
        self.master.bind('<s>', lambda event: self.skip_if_enabled())
        self.master.bind('<S>', lambda event: self.skip_if_enabled())
        
        # Log startup info
        logger.info(f"AnythingLLM Word Batch Processor v{VERSION} started")
    
    def approve_if_enabled(self):
        """Handle approve keyboard shortcut"""
        if self.approve_button.cget('state') != tk.DISABLED:
            self.approve_question()
    
    def skip_if_enabled(self):
        """Handle skip keyboard shortcut"""
        if self.skip_button.cget('state') != tk.DISABLED:
            self.skip_question()
    
    def browse_input(self):
        """Open file dialog to select input Word document(s)"""
        # Start in the last used directory if available
        initial_dir = self.config.get("last_input_dir", os.path.expanduser("~"))
        
        # Ensure the initial directory exists
        if not os.path.exists(initial_dir):
            initial_dir = os.path.expanduser("~")
            
        filenames = filedialog.askopenfilenames(
            title="Select Word Document(s)",
            initialdir=initial_dir,
            filetypes=[("Word Documents", "*.docx"), ("All Files", "*.*")]
        )
        
        if filenames and len(filenames) > 0:
            # Get just the directory path (without filename)
            directory_path = os.path.dirname(filenames[0])
            
            # Extract just the filenames for display
            if len(filenames) == 1:
                # Single file - show the filename
                filename_display = os.path.basename(filenames[0])
            else:
                # Multiple files - show count and first filename
                filename_display = f"{os.path.basename(filenames[0])} and {len(filenames)-1} more files"
            
            # Store full paths to use when processing begins
            files_str = ";".join(filenames)
            self.input_file = files_str
            
            # Update filename entry - show just the filename(s)
            self.input_filename_var.set(filename_display)
            self.input_filename_entry.config(state="normal")
            self.input_filename_entry.delete(0, tk.END)
            self.input_filename_entry.insert(0, filename_display)
            self.input_filename_entry.config(state="readonly")
            
            # Update path entry - show just the directory path
            self.input_path_var.set(directory_path)
            self.input_path_entry.config(state="normal")
            self.input_path_entry.delete(0, tk.END)
            self.input_path_entry.insert(0, directory_path)
            self.input_path_entry.config(state="readonly")
            
            # Ensure entries have correct colors and states
            self.input_filename_entry.config(fg="black", bg="#ffffff", readonlybackground="#f0f0f0")
            self.input_path_entry.config(fg="black", bg="#ffffff", readonlybackground="#f0f0f0")
            
            # Remember the files and directory
            self.config["last_input_file"] = files_str
            self.config["last_input_dir"] = directory_path
            save_config(self.config)
            
            # Suggest an output filename based on first input
            input_name = os.path.splitext(os.path.basename(filenames[0]))[0]
            if len(filenames) > 1:
                input_name += f"_and_{len(filenames)-1}_more"
            
            output_filename = f"{input_name}_processed.docx"
            
            if self.config.get("last_output_dir"):
                suggested_output = os.path.join(self.config["last_output_dir"], output_filename)
            else:
                suggested_output = os.path.join(directory_path, output_filename)
            
            # Update the output fields
            self.output_filename_var.set(output_filename)
            self.output_path_var.set(os.path.dirname(suggested_output))
            
            # Make sure output fields are properly configured too
            self.output_path_entry.config(fg="black", bg="#ffffff", readonlybackground="#f0f0f0")
            self.output_path_entry.config(state="readonly")
            
            self.output_file = suggested_output
            
            # Also remember this suggested output file
            self.config["last_output_file"] = suggested_output
            save_config(self.config)
            
            # Log the selection
            if len(filenames) == 1:
                logger.info(f"Selected input file: {filenames[0]}")
            else:
                logger.info(f"Selected {len(filenames)} input files")
            
            # Update status to provide feedback
            self.progress_var.set(f"Selected {len(filenames)} input file(s)")
            
            # Force update the UI
            self.master.update_idletasks()
        else:
            logger.info("No files selected or file selection canceled")
            self.progress_var.set("No files selected")
    
    def browse_output(self):
        """Open file dialog to select output Word document"""
        # Start in the last used directory if available
        initial_dir = self.config.get("last_output_dir", self.config.get("last_input_dir", os.path.expanduser("~")))
        
        filename = filedialog.asksaveasfilename(
            title="Save Processed Document As",
            initialdir=initial_dir,
            defaultextension=".docx",
            filetypes=[("Word Documents", "*.docx"), ("All Files", "*.*")]
        )
        if filename:
            # Update both the filename and path fields
            self.output_filename_var.set(os.path.basename(filename))
            
            # Temporarily enable output path entry for update
            self.output_path_entry.config(state="normal")
            self.output_path_var.set(os.path.dirname(filename))
            self.output_path_entry.config(state="readonly")
            
            self.output_file = filename
            
            # Remember this file and directory
            self.config["last_output_file"] = filename
            self.config["last_output_dir"] = os.path.dirname(filename)
            save_config(self.config)
    
    def start_processing(self):
        """Start the document processing"""
        # When browse_input was called, the full paths were stored in self.input_file
        # We should NOT overwrite this with just the path from input_path_var
        
        # Construct the output file path from filename and directory
        output_filename = self.output_filename_var.get()
        output_dir = self.output_path_var.get()
        
        if output_dir and output_filename:
            self.output_file = os.path.join(output_dir, output_filename)
        else:
            self.output_file = self.output_filename_var.get()  # Fallback to just the filename
        
        # Check for valid input files
        if not hasattr(self, 'input_file') or not self.input_file:
            messagebox.showerror("Error", "Please select at least one valid input Word document.")
            return
        
        input_files = self.input_file.split(";")
        valid_files = []
        
        for file_path in input_files:
            if os.path.exists(file_path) and os.path.isfile(file_path):
                valid_files.append(file_path)
            else:
                logger.warning(f"Input file does not exist or is not a file: {file_path}")
        
        if not valid_files:
            messagebox.showerror("Error", "Please select at least one valid input Word document.")
            return
        
        if not self.output_file:
            messagebox.showerror("Error", "Please specify an output Word document.")
            return
        
        # Get the API key from the hardcoded value
        api_key = API_KEY
        
        # Save the current file paths and API settings
        self.config["last_input_file"] = self.input_file
        self.config["last_output_file"] = self.output_file
        self.config["api_endpoint"] = self.api_endpoint_var.get().strip()
        self.config["api_key"] = api_key  # Use hardcoded API key
        self.config["model"] = self.model_var.get()
        save_config(self.config)
        
        # Log processing start for Cursor AI
        log_for_cursor("processing_start", f"Started processing documents", {
            "input_files": input_files,
            "num_files": len(valid_files),
            "output_file": self.output_file,
            "api_endpoint": self.api_endpoint_var.get(),
            "model": self.model_var.get()
        })
        
        # Process each file
        self.all_files_results = []
        self.pending_questions = []
        self.current_file_index = 0
        self.valid_input_files = valid_files
        
        # Start processing the first file
        self.process_next_file()
    
    def process_next_file(self):
        """Process the next file in the list"""
        if self.current_file_index >= len(self.valid_input_files):
            # All files processed, create the output
            self.progress_var.set("All files processed. Creating output document...")
            self.update_progress_bar(90)
            
            # Create the output document in a separate thread
            self.processing_thread = threading.Thread(target=self.create_output_document)
            self.processing_thread.daemon = True
            self.processing_thread.start()
            return
        
        # Get the current file to process
        current_file = self.valid_input_files[self.current_file_index]
        self.current_file_index += 1
        
        # Update status
        progress_msg = f"Processing file {self.current_file_index}/{len(self.valid_input_files)}: {os.path.basename(current_file)}"
        self.progress_var.set(progress_msg)
        
        # Initialize the document reader for this file
        self.doc_reader = DocumentReader(current_file)
        self.results = []  # Clear results for this file
        
        # Start API worker threads if not already started
        if not hasattr(self, 'api_threads') or not any(thread.is_alive() for thread in self.api_threads):
            self.start_api_workers()
        
        # Update UI for processing state
        self.is_processing = True
        self.start_button.config(state=tk.DISABLED)
        self.approve_button.config(state=tk.NORMAL)
        self.skip_button.config(state=tk.NORMAL)
        self.stop_button.config(state=tk.NORMAL)
        self.save_progress_button.config(state=tk.NORMAL)
        self.manage_queue_button.config(state=tk.DISABLED)  # Enable only when questions are in queue
        
        # Update progress bar
        progress = int((self.current_file_index - 1) / len(self.valid_input_files) * 100)
        self.update_progress_bar(progress, progress_msg)
        
        # Load cached questions for this document
        self.load_cached_questions()
        
        # Load the first question
        self.load_next_question()
    
    def start_api_workers(self):
        """Start background threads to process API requests"""
        # Clear any existing threads that aren't active
        self.api_threads = [thread for thread in self.api_threads if thread.is_alive()]
        
        # Add new threads up to the maximum
        threads_needed = self.max_api_threads - len(self.api_threads)
        logger.info(f"Starting {threads_needed} new API worker threads")
        
        for i in range(threads_needed):
            thread = threading.Thread(target=self.api_worker, daemon=True)
            thread.start()
            self.api_threads.append(thread)
            logger.info(f"Started API worker thread {len(self.api_threads)}")
    
    def api_worker(self):
        """Worker thread that processes API requests from the queue"""
        while self.is_processing:
            try:
                # Get the next question from the queue, with a timeout
                # to allow the thread to check if processing has stopped
                try:
                    question_data = self.api_queue.get(timeout=1)
                    logger.info(f"API worker received question from queue: {question_data['question'][:50]}...")
                except queue.Empty:
                    continue
                
                # Increment active request counter
                self.master.after(0, self.increment_api_requests)
                
                # Process the question
                try:
                    logger.info(f"API worker processing question: {question_data['question'][:50]}...")
                    
                    # Record start time for this request
                    request_start_time = time.time()
                    
                    # Send request to AnythingLLM
                    result = self.send_to_anythingllm(question_data)
                    
                    # Record completion time
                    completion_time = time.time() - request_start_time
                    
                    # Process results
                    if result:
                        logger.info(f"API request completed successfully in {completion_time:.2f}s")
                        # Add to results safely
                        self.master.after(0, lambda r=result: self.add_result(r))
                    else:
                        # Log the API failure details for debugging
                        logger.error(f"Failed to get API response for question: {question_data['question'][:50]}...")
                        logger.error(f"Last error: {API_REQUESTS['last_error']}")
                        logger.error("Check that AnythingLLM is running and the API is configured correctly")
                        
                        # Update the UI with the failure
                        self.master.after(0, lambda: self.progress_var.set(
                            f"API request failed: {API_REQUESTS['last_error'] or 'Unknown error'}"
                        ))
                except Exception as e:
                    logger.exception(f"Error in API worker: {str(e)}")
                    # Update the UI with the error
                    self.master.after(0, lambda err=str(e): self.progress_var.set(f"Error: {err}"))
                
                # Decrement active request counter
                self.master.after(0, self.decrement_api_requests)
                
                # Mark the task as done
                self.api_queue.task_done()
            except Exception as e:
                logger.exception(f"Unexpected error in API worker: {str(e)}")
                # Make sure to decrement in case of error
                self.master.after(0, self.decrement_api_requests)
    
    def increment_api_requests(self):
        """Increment the active API requests counter"""
        self.active_api_requests += 1
        if self.active_api_requests == 1:
            # First active request
            self.draw_api_indicator("active")
    
    def decrement_api_requests(self):
        """Decrement the active API requests counter"""
        self.active_api_requests = max(0, self.active_api_requests - 1)
        if self.active_api_requests == 0:
            # No more active requests
            self.draw_api_indicator("idle")
    
    def add_result(self, result):
        """Add a result to the results list (called from worker thread via after)"""
        if not self.is_processing:
            return
            
        self.results.append(result)
        answer = result['answer']
        logger.info(f"Added result #{len(self.results)} with answer: {answer}")
        
        # Save to database
        self.save_to_database(result)
        
        # Update the progress status
        self.update_status(f"Received answer {answer} for question {len(self.results)}")
        
        # Re-enable save progress button if it was disabled
        self.save_progress_button.config(state=tk.NORMAL)
    
    def update_status(self, message):
        """Update status message in the UI"""
        self.progress_var.set(message)
        logger.info(message)
    
    def check_api_results(self):
        """Periodically check for API results and update progress"""
        if self.is_processing:
            # Update progress bar based on completed questions
            if self.doc_reader:
                pending = self.api_queue.qsize()
                extracted = self.doc_reader.current_position
                
                # Use all_files_results if it exists, otherwise use results
                if hasattr(self, 'all_files_results'):
                    completed = len(self.all_files_results)
                else:
                    completed = len(self.results)
                
                total = max(1, self.doc_reader.total_paragraphs)  # Avoid division by zero
                
                # Show progress info
                progress_msg = f"Completed: {completed}, Pending: {pending}, Reviewed: {extracted}/{total}"
                
                # If processing multiple files, add file info
                if hasattr(self, 'valid_input_files') and hasattr(self, 'current_file_index'):
                    progress_msg = f"File {self.current_file_index}/{len(self.valid_input_files)}: " + progress_msg
                
                self.progress_var.set(progress_msg)
                
                # Update progress bar - base it on extraction progress
                progress = int((extracted / total) * 100)
                
                # If processing multiple files, adjust the progress for the current file's portion
                if hasattr(self, 'valid_input_files') and hasattr(self, 'current_file_index') and len(self.valid_input_files) > 0:
                    file_progress = int((self.current_file_index - 1) / len(self.valid_input_files) * 100)
                    file_progress_portion = int((progress / 100) * (100 / len(self.valid_input_files)))
                    progress = min(file_progress + file_progress_portion, 100)
                
                self.update_progress_bar(min(progress, 100))
                
                # Update API activity indicator
                if self.active_api_requests > 0 and self.api_activity_indicator:
                    self.draw_api_indicator("active")
                elif self.api_activity_indicator:
                    self.draw_api_indicator("idle")
        
            # Schedule the next check - more frequent updates (500ms → 200ms)
            self.master.after(200, self.check_api_results)
        else:
            # Schedule less frequent checks when not processing
            self.master.after(1000, self.check_api_results)
    
    def load_next_question(self):
        """Load the next question from the document for user approval"""
        if not self.is_processing:
            return
            
        # Get questions in a loop until we find one we need to process
        while True:
            # Get the next question
            question_data = self.doc_reader.get_next_question()
            
            # If no more questions, move to next file or finish processing
            if not question_data:
                self.current_question = None
                self.clear_question_preview()
                
                # Disable interaction buttons
                self.approve_button.config(state=tk.DISABLED)
                self.skip_button.config(state=tk.DISABLED)
                
                # Save results from this file to the all_files_results list
                if self.results:
                    self.all_files_results.extend(self.results)
                    logger.info(f"Added {len(self.results)} results from file {self.current_file_index}/{len(self.valid_input_files)}")
                
                # Update status and progress
                pending = self.api_queue.qsize()
                if hasattr(self, 'all_files_results'):
                    completed = len(self.all_files_results)
                else:
                    completed = len(self.results)
                
                if self.current_file_index < len(self.valid_input_files):
                    # Move to next file
                    progress_msg = f"Moving to next file. Completed {completed} questions."
                    # Update progress to show completion of current file
                    progress = int((self.current_file_index) / len(self.valid_input_files) * 100)
                    self.update_progress_bar(progress, progress_msg)
                    self.process_next_file()
                    return
                elif pending > 0:
                    progress_msg = f"All files reviewed. Waiting for {pending} pending API responses..."
                    self.update_progress_bar(95, progress_msg)
                elif completed > 0:
                    # All done, create the output
                    self.progress_var.set("All files processed. Creating output document...")
                    self.update_progress_bar(90)
                    
                    # Create the output document in a separate thread
                    self.processing_thread = threading.Thread(target=self.create_output_document)
                    self.processing_thread.daemon = True
                    self.processing_thread.start()
                else:
                    # No results
                    self.progress_var.set("No questions were processed")
                    self.update_progress_bar(100)
                    self.complete_processing(False)
                return
            
            # Create hash for this question
            question_hash = hash_question(question_data['question'], question_data['options'])
            
            # Check if this question was previously skipped
            if hasattr(self, 'skipped_questions') and question_hash in self.skipped_questions:
                logger.info(f"Skipping previously marked question: {question_data['question'][:50]}...")
                continue  # Skip this question and get the next one
            
            # Check if we already have this question in the cache (completed)
            if question_hash in self.cached_questions:
                cached = self.cached_questions[question_hash]
                logger.info(f"Found cached answer for completed question: {question_data['question'][:50]}...")
                
                # Add to results directly
                self.results.append({
                    'question': cached['question'],
                    'options': cached['options'],
                    'answer': cached['answer'],
                    'reasoning': cached['reasoning'],
                    'citations': cached['citations'],
                    'from_cache': True
                })
                
                # Show that we're using cached data
                self.progress_var.set(f"Using cached answer: {cached['answer']} for question {len(self.results)}")
                
                # Continue to next question
                continue
            
            # We've found a question that needs processing
            self.current_question = question_data
            
            # Update the question preview
            self.update_question_preview(question_data)
            
            # Update progress with better feedback
            if self.doc_reader.total_paragraphs > 0:
                progress = int((self.doc_reader.current_position / self.doc_reader.total_paragraphs) * 100)
                # Scale the progress to the current file's portion of total progress
                file_progress = int((self.current_file_index - 1) / len(self.valid_input_files) * 100)
                file_progress_portion = int((progress / 100) * (100 / len(self.valid_input_files)))
                total_progress = min(file_progress + file_progress_portion, 100)
                
                progress_msg = f"File {self.current_file_index}/{len(self.valid_input_files)}: Question ready for review"
                self.update_progress_bar(total_progress, progress_msg)
            
            self.progress_var.set(f"File {self.current_file_index}/{len(self.valid_input_files)}: Question ready for review")
            
            logger.info(f"Loaded question for review: {question_data['question'][:50]}...")
            
            # Re-enable buttons for interaction
            self.approve_button.config(state=tk.NORMAL)
            self.skip_button.config(state=tk.NORMAL)
            return  # Found a question to process, exit the loop
    
    def update_question_preview(self, question_data):
        """Update the question preview widget with the current question"""
        self.question_text.configure(state='normal')
        self.question_text.delete('1.0', tk.END)
        
        # Add the question
        self.question_text.insert(tk.END, "Question:\n", "heading")
        self.question_text.insert(tk.END, question_data['question'] + "\n\n")
        
        # Add the options
        self.question_text.insert(tk.END, "Options:\n", "heading")
        for option in question_data['options']:
            self.question_text.insert(tk.END, f"{option['letter']}. {option['text']}\n")
        
        self.question_text.configure(state='disabled')
    
    def clear_question_preview(self):
        """Clear the question preview widget"""
        self.question_text.configure(state='normal')
        self.question_text.delete('1.0', tk.END)
        self.question_text.insert(tk.END, "No more questions available.")
        self.question_text.configure(state='disabled')
        
    def skip_question(self):
        """Skip the current question and load the next one"""
        if not self.is_processing or not self.current_question:
            return
        
        # Get the question text and remove "Question: " prefix if present
        question_text = self.current_question['question']
        if question_text.startswith("Question: "):
            question_text = question_text[10:].strip()
            # Update the current question with the cleaned text
            self.current_question['question'] = question_text
        
        # Create a hash for the current question to store in the database
        question_hash = hash_question(question_text, self.current_question['options'])
        
        # Mark question as skipped in the database
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # First check if this question already exists
            cursor.execute('SELECT id FROM questions WHERE question_hash = ?', (question_hash,))
            question_id = cursor.fetchone()
            
            if question_id:
                # Update existing question to mark as skipped
                cursor.execute('''
                UPDATE questions SET status = 'skipped', processed_date = ? WHERE id = ?
                ''', (time.strftime("%Y-%m-%d %H:%M:%S"), question_id[0]))
                logger.info(f"Marked existing question as skipped: {question_hash[:10]}...")
            else:
                # Insert new question with skipped status
                cursor.execute('''
                INSERT INTO questions (question_hash, question_text, source_file, processed_date, status)
                VALUES (?, ?, ?, ?, 'skipped')
                ''', (question_hash, question_text, self.input_file, time.strftime("%Y-%m-%d %H:%M:%S")))
                
                question_id = cursor.lastrowid
                
                # Insert options
                for option in self.current_question['options']:
                    cursor.execute('''
                    INSERT INTO options (question_id, letter, text)
                    VALUES (?, ?, ?)
                    ''', (question_id, option['letter'], option['text']))
                
                logger.info(f"Added new skipped question to database: {question_hash[:10]}...")
            
            conn.commit()
            conn.close()
            
            # Add to skipped questions set
            self.skipped_questions.add(question_hash)
            
        except Exception as e:
            logger.exception(f"Error marking question as skipped: {str(e)}")
        
        logger.info(f"Skipping question: {question_text[:50]}...")
        self.load_next_question()
    
    def approve_question(self):
        """User approved the current question, add it to pending queue"""
        if not self.is_processing or not self.current_question:
            return
            
        # Add the question to the pending questions list
        logger.info(f"Adding approved question to pending queue: {self.current_question['question'][:50]}...")
        self.pending_questions.append(self.current_question.copy())
        
        # Update UI
        self.manage_queue_button.config(state=tk.NORMAL)
        self.update_status(f"Added question to queue (total: {len(self.pending_questions)})")
        
        # Load the next question
        self.load_next_question()
    
    def process_approved_question(self):
        """Process the approved question in a separate thread - no longer used"""
        # This method is kept for historical purposes but is no longer used
        # API processing is now handled by worker threads
        pass
    
    def complete_processing(self, success):
        """Reset UI after processing is complete"""
        self.is_processing = False
        self.start_button.config(state=tk.NORMAL)
        self.approve_button.config(state=tk.DISABLED)
        self.skip_button.config(state=tk.DISABLED)
        self.stop_button.config(state=tk.DISABLED)
        self.save_progress_button.config(state=tk.DISABLED)
        
        if success:
            messagebox.showinfo("Processing Complete", 
                              f"Document processed successfully and saved to:\n{self.output_file}")
    
    def stop_processing(self):
        """Stop the processing"""
        if self.is_processing:
            self.is_processing = False
            
            # Wait for API queue to be processed
            pending = self.api_queue.qsize()
            if pending > 0:
                if messagebox.askyesno("Pending Questions", 
                                       f"There are {pending} questions waiting to be processed. Wait for them to complete?"):
                    # Wait for queue to finish
                    self.progress_var.set(f"Waiting for {pending} pending questions to complete...")
                    
                    # Disable all buttons during wait
                    self.approve_button.config(state=tk.DISABLED)
                    self.skip_button.config(state=tk.DISABLED)
                    self.stop_button.config(state=tk.DISABLED)
                    
                    # Start a thread to wait for queue
                    wait_thread = threading.Thread(target=self.wait_for_queue)
                    wait_thread.daemon = True
                    wait_thread.start()
                    return
            
            # If not waiting, complete right away
            self.progress_var.set("Processing stopped by user")
            logger.info("Processing was stopped by user")
            
            # Always save progress when stopping
            if self.results:
                # Create the output document
                self.create_output_document()
            else:
                self.complete_processing(False)
    
    def wait_for_queue(self):
        """Wait for the API queue to finish processing"""
        try:
            # Wait with a timeout
            self.api_queue.join()
            
            # Create output document
            self.master.after(0, self.create_output_document)
        except Exception as e:
            logger.exception(f"Error waiting for queue: {str(e)}")
            self.master.after(0, lambda: self.complete_processing(False))
    
    def create_output_document(self, complete_after=True):
        """Create the output document with the results"""
        try:
            # Use all_files_results instead of results
            if not hasattr(self, 'all_files_results') or not self.all_files_results:
                self.progress_var.set("No results to save")
                log_for_cursor("document_creation_error", "No results to save")
                if complete_after:
                    self.complete_processing(False)
                return
                
            self.progress_var.set("Creating output document...")
            
            # Log document creation start for Cursor AI
            log_for_cursor("document_creation_start", f"Creating output document", {
                "output_file": self.output_file,
                "num_results": len(self.all_files_results)
            })
            
            self.create_result_document(self.all_files_results, self.output_file)
            self.progress_var.set(f"Document saved to {self.output_file}")
            self.progress_bar.config(value=100)
            logger.info(f"Document saved to {self.output_file}")
            
            # Log document creation completion for Cursor AI
            log_for_cursor("document_creation_complete", f"Output document created successfully", {
                "output_file": self.output_file,
                "num_results": len(self.all_files_results)
            })
            
            if complete_after:
                self.complete_processing(True)
            else:
                # Just re-enable the save button
                self.save_progress_button.config(state=tk.NORMAL)
        except Exception as e:
            logger.exception(f"Error creating output document: {str(e)}")
            self.progress_var.set(f"Error creating document: {str(e)}")
            
            # Log error for Cursor AI
            log_for_cursor("document_creation_error", f"Error creating output document", {
                "error": str(e)
            })
            
            if complete_after:
                self.complete_processing(False)
            else:
                self.save_progress_button.config(state=tk.NORMAL)
    
    def send_to_anythingllm(self, question_data):
        """
        Send question to AnythingLLM API and get response
        Returns a dictionary with question, options, answer, reasoning, and citations
        """
        question = question_data['question']
        options = question_data['options']
        
        # Format options as a string
        options_text = ""
        for option in options:
            options_text += f"{option['letter']}. {option['text']}\n"
        
        # Check if the question actually asks something
        has_question_mark = "?" in question
        
        # Create the prompt for the API - add clarity if needed
        if not has_question_mark:
            prompt = f"""
Question: {question}

Which ONE of the following options is correct?

Options:
{options_text}

IMPORTANT: Base your answer ONLY on the Nokia Optical documentation loaded into your knowledge base.
Do NOT use any external knowledge or general information not found in the Nokia Optical documentation.

Please analyze this question and provide:
1. The correct answer (just the letter A, B, C, or D)
2. A detailed explanation of your reasoning, including why the correct answer is right AND why each of the other options is incorrect
3. Citations that specifically reference the Nokia Optical documentation (section, page number, paragraph, etc.)

Format your response exactly like this:
ANSWER: [letter]
REASONING: [your detailed reasoning explaining why the correct answer is right AND why each other option is wrong, based only on the Nokia Optical documentation]
CITATIONS: [specific location in the Nokia Optical documentation where this information appears]
"""
        else:
            prompt = f"""
Question: {question}

Options:
{options_text}

IMPORTANT: Base your answer ONLY on the Nokia Optical documentation loaded into your knowledge base.
Do NOT use any external knowledge or general information not found in the Nokia Optical documentation.

Please analyze this question and provide:
1. The correct answer (just the letter A, B, C, or D)
2. A detailed explanation of your reasoning, including why the correct answer is right AND why each of the other options is incorrect
3. Citations that specifically reference the Nokia Optical documentation (section, page number, paragraph, etc.)

Format your response exactly like this:
ANSWER: [letter]
REASONING: [your detailed reasoning explaining why the correct answer is right AND why each other option is wrong, based only on the Nokia Optical documentation]
CITATIONS: [specific location in the Nokia Optical documentation where this information appears]
"""
        
        # Get API configuration - use hardcoded key
        api_key = API_KEY
        
        # Prepare the API request headers
        headers = {
            "Content-Type": "application/json"
        }
        if api_key:
            headers["Authorization"] = f"Bearer {api_key}"  # Use hardcoded API key
        else:
            logger.warning("No API key provided; proceeding without Authorization header.")
        
        # Use the endpoint from the endpoint field
        api_endpoint = self.api_endpoint_var.get().strip()
        
        # Get the timeout value - default to 90 seconds if not a valid number
        try:
            timeout = int(self.timeout_var.get().strip())
            if timeout < 10:  # Enforce minimum timeout of 10 seconds
                timeout = 10
            elif timeout > 300:  # Cap at 5 minutes to prevent indefinite hangs
                timeout = 300
        except (ValueError, AttributeError):
            timeout = 90  # Default timeout of 90 seconds (increased from 60)
            
        logger.info(f"Using API endpoint: {api_endpoint}")
        logger.info(f"Using model: {self.model_var.get().strip()}")
        logger.info(f"Using timeout: {timeout} seconds")
        
        # Save timeout setting to config
        self.config["api_timeout"] = str(timeout)
        save_config(self.config)
        
        # Log API request for Cursor AI
        log_for_cursor("api_request_start", f"Sending API request", {
            "question_id": hashlib.md5(question.encode()).hexdigest()[:8],
            "question_preview": question[:50] + ("..." if len(question) > 50 else ""),
            "num_options": len(options),
            "api_endpoint": api_endpoint,
            "model": self.model_var.get().strip(),
            "timeout": timeout
        })
        
        # Standard OpenAI-compatible request format
        data = {
            "model": self.model_var.get().strip(),
            "messages": [
                {"role": "system", "content": "You are a helpful assistant specializing in Nokia Optical documentation."},
                {"role": "user", "content": prompt}
            ],
            "temperature": 0.1,
            "max_tokens": 2000
        }
        
        logger.info(f"Sending request to API: {api_endpoint}")
        logger.info(f"Question: {question[:50]}...")
        
        try:
            # Log the full request for debugging and diagnosis
            logger.info(f"API Request URL: {api_endpoint}")
            logger.info(f"API Request Headers: {headers}")
            logger.debug(f"API Request Data: {json.dumps(data, indent=2)[:1000]}")
            
            # Record start time for this request
            request_start_time = time.time()
            API_REQUESTS['last_request_time'] = request_start_time
            API_REQUESTS['total_sent'] += 1
            
            # Send the request to the API with the configured timeout
            response = requests.post(
                api_endpoint,
                headers=headers,
                json=data,
                timeout=timeout
            )
            
            # Record response time
            response_end_time = time.time()
            API_REQUESTS['last_response_time'] = response_end_time
            response_time = response_end_time - request_start_time
            logger.info(f"API response received in {response_time:.2f}s")
            
            # Check if the request was successful
            response.raise_for_status()
            
            # Parse the response - update this to handle OpenAI format
            result = response.json()
            logger.info(f"API response: {json.dumps(result, indent=2)[:1000]}...")
            API_REQUESTS['successful'] += 1
            
            # Extract the content from the response - OpenAI format
            if "choices" in result and len(result["choices"]) > 0:
                content = result["choices"][0]["message"]["content"]
                logger.info(f"Response content length: {len(content)} characters")
                
                # Parse the content to extract answer, reasoning, and citations
                answer, reasoning, citations = self.parse_anythingllm_response(content)
                
                # Log successful API response for Cursor AI
                log_for_cursor("api_request_success", f"API request successful", {
                    "question_id": hashlib.md5(question.encode()).hexdigest()[:8],
                    "response_time": round(response_time, 2),
                    "answer": answer,
                    "reasoning_length": len(reasoning),
                    "citations_length": len(citations)
                })
                
                return {
                    'question': question,
                    'options': options,
                    'answer': answer,
                    'reasoning': reasoning,
                    'citations': citations
                }
            else:
                logger.error("Invalid API response format")
                logger.error(f"Full response: {result}")
                API_REQUESTS['failed'] += 1
                API_REQUESTS['last_error'] = "Invalid API response format"
                
                # Log failed API response for Cursor AI
                log_for_cursor("api_request_error", f"Invalid API response format", {
                    "question_id": hashlib.md5(question.encode()).hexdigest()[:8],
                    "response_time": round(response_time, 2),
                    "error": "Invalid API response format"
                })
                
                return None
                
        except requests.exceptions.Timeout:
            # Specific handler for timeout exceptions
            error_msg = f"API request timed out after {timeout} seconds - try increasing the timeout setting"
            logger.error(error_msg)
            API_REQUESTS['failed'] += 1
            API_REQUESTS['last_error'] = error_msg
            
            # Mark this question as incomplete in the database instead of just failing
            self.mark_question_as_incomplete(question, options)
            
            # Show a more helpful message for timeouts - with auto-close
            def show_timeout_message():
                timeout_dialog = tk.Toplevel(self.master)
                timeout_dialog.title("API Timeout")
                timeout_dialog.geometry("400x200")
                timeout_dialog.transient(self.master)  # Stay on top of main window
                
                # Add message
                message = f"The API request timed out after {timeout} seconds.\n\n" \
                          f"This usually happens with complex questions or slower models.\n\n" \
                          f"The question has been marked as 'incomplete' and can be retried later."
                
                tk.Label(timeout_dialog, text=message, wraplength=380, justify=tk.LEFT).pack(padx=20, pady=20)
                
                # Add close button
                close_button = tk.Button(timeout_dialog, text="Close", command=timeout_dialog.destroy)
                close_button.pack(pady=10)
                
                # Auto-close after 3 seconds
                timeout_dialog.after(3000, timeout_dialog.destroy)
                
                # Center on main window
                timeout_dialog.update_idletasks()
                main_x = self.master.winfo_x()
                main_y = self.master.winfo_y()
                main_width = self.master.winfo_width()
                main_height = self.master.winfo_height()
                dialog_width = timeout_dialog.winfo_width()
                dialog_height = timeout_dialog.winfo_height()
                
                x = main_x + (main_width - dialog_width) // 2
                y = main_y + (main_height - dialog_height) // 2
                timeout_dialog.geometry(f"+{x}+{y}")
            
            # Schedule message to show on main thread
            self.master.after(0, show_timeout_message)
            
            # Log timeout error for Cursor AI
            log_for_cursor("api_request_timeout", f"API request timed out", {
                "question_id": hashlib.md5(question.encode()).hexdigest()[:8],
                "timeout_seconds": timeout,
                "error": error_msg
            })
            
            return None
        except requests.exceptions.ConnectionError:
            # Connection error - AnythingLLM probably not running
            error_msg = "Connection error - AnythingLLM API not running or not accessible"
            logger.error(error_msg)
            API_REQUESTS['failed'] += 1
            API_REQUESTS['last_error'] = error_msg
            
            # Mark this question as incomplete
            self.mark_question_as_incomplete(question, options)
            
            # Log API request failure for Cursor AI
            log_for_cursor("api_request_error", f"API connection error", {
                "question_id": hashlib.md5(question.encode()).hexdigest()[:8],
                "error": error_msg
            })
            
            return None
        except requests.exceptions.RequestException as e:
            # General request exception
            error_msg = f"API request failed: {str(e)}"
            logger.error(error_msg)
            API_REQUESTS['failed'] += 1
            API_REQUESTS['last_error'] = error_msg
            
            # Mark this question as incomplete
            self.mark_question_as_incomplete(question, options)
            
            # Log API request failure for Cursor AI
            log_for_cursor("api_request_error", f"API request failed", {
                "question_id": hashlib.md5(question.encode()).hexdigest()[:8],
                "error": str(e)
            })
            
            return None
        except Exception as e:
            error_msg = f"Error processing API response: {str(e)}"
            logger.error(error_msg)
            logger.error(f"Response content: {response.text if 'response' in locals() else 'No response'}")
            API_REQUESTS['failed'] += 1
            API_REQUESTS['last_error'] = str(e)
            
            # Mark this question as incomplete
            self.mark_question_as_incomplete(question, options)
            
            # Log unexpected error for Cursor AI
            log_for_cursor("api_request_error", f"Error processing API response", {
                "question_id": hashlib.md5(question.encode()).hexdigest()[:8],
                "error": str(e)
            })
            
            return None
    
    def mark_question_as_incomplete(self, question, options):
        """Mark a question as incomplete in the database so it can be retried later"""
        try:
            # Remove "Question: " prefix if present
            if question.startswith("Question: "):
                question = question[10:].strip()
                
            # Create a hash for the question
            question_hash = hash_question(question, options)
            
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Check if question already exists
            cursor.execute('SELECT id, status FROM questions WHERE question_hash = ?', (question_hash,))
            existing = cursor.fetchone()
            
            if existing:
                question_id = existing[0]
                current_status = existing[1]
                
                # Only update if not already completed
                if current_status != 'completed':
                    # Update to incomplete status
                    cursor.execute('''
                    UPDATE questions SET status = 'incomplete', processed_date = ?
                    WHERE id = ?
                    ''', (time.strftime("%Y-%m-%d %H:%M:%S"), question_id))
                    logger.info(f"Marked existing question as incomplete: {question_hash[:10]}...")
            else:
                # Insert as new question with incomplete status
                cursor.execute('''
                INSERT INTO questions (question_hash, question_text, source_file, processed_date, status)
                VALUES (?, ?, ?, ?, 'incomplete')
                ''', (question_hash, question, self.input_file, time.strftime("%Y-%m-%d %H:%M:%S")))
                
                question_id = cursor.lastrowid
                
                # Insert options
                for option in options:
                    cursor.execute('''
                    INSERT INTO options (question_id, letter, text)
                    VALUES (?, ?, ?)
                    ''', (question_id, option['letter'], option['text']))
                
                logger.info(f"Added new incomplete question to database: {question_hash[:10]}...")
            
            conn.commit()
            conn.close()
            
        except Exception as e:
            logger.exception(f"Error marking question as incomplete: {str(e)}")
    
    def parse_anythingllm_response(self, response_text):
        """
        Parse the response from AnythingLLM API to extract answer, reasoning, and citations
        Returns a tuple of (answer, reasoning, citations)
        """
        # Default values
        answer = "Unknown"
        reasoning = "No reasoning provided"
        citations = "No citations provided"
        
        # Extract answer
        answer_match = re.search(r'ANSWER:\s*([A-D])', response_text, re.IGNORECASE)
        if answer_match:
            answer = answer_match.group(1).upper()
        
        # Extract reasoning - improved pattern to handle various formats
        reasoning_match = re.search(r'REASONING:\s*(.*?)(?=CITATIONS:|$)', response_text, re.IGNORECASE | re.DOTALL)
        if reasoning_match:
            reasoning = reasoning_match.group(1).strip()
        
        # Extract citations - improved pattern to handle various formats
        citations_match = re.search(r'CITATIONS:\s*(.*?)(?=\n\n|$)', response_text, re.IGNORECASE | re.DOTALL)
        if citations_match:
            citations = citations_match.group(1).strip()
            
            # Clean up citations if they're in a strange format
            if len(citations) < 5 or "not found" in citations.lower() or "n/a" in citations.lower():
                citations = "Citations not found in the loaded document"
                logger.warning(f"Potentially invalid citations detected: {citations}")
        
        logger.info(f"Parsed response - Answer: {answer}, Reasoning length: {len(reasoning)}, Citations length: {len(citations)}")
        return answer, reasoning, citations
        
    def quit_application(self):
        """Quit the application after confirmation"""
        if self.is_processing:
            if not messagebox.askyesno("Confirm Quit", "Processing is in progress. Are you sure you want to quit?"):
                return
        
        # Save any current configuration
        if self.api_endpoint_var.get():
            self.config["api_endpoint"] = self.api_endpoint_var.get()
        if self.model_var.get():
            self.config["model"] = self.model_var.get()
        if hasattr(self, 'timeout_var') and self.timeout_var.get():
            self.config["api_timeout"] = self.timeout_var.get()
        save_config(self.config)
        
        # Stop GPU monitoring
        self.stop_gpu_monitoring()
        
        logger.info("Application closed by user")
        self.master.destroy()
    
    def load_cached_questions(self):
        """Load cached questions from the database for the current document"""
        if not hasattr(self, 'input_file') or not self.input_file:
            self.cached_questions = {}
            self.skipped_questions = set()  # Initialize skipped questions set
            self.update_db_stats()
            return
            
        try:
            conn = sqlite3.connect(DB_FILE)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Query for questions from this document with answers (status completed)
            cursor.execute('''
            SELECT q.id, q.question_hash, q.question_text, q.status, a.answer, a.reasoning, a.citations
            FROM questions q
            LEFT JOIN answers a ON q.id = a.question_id
            WHERE q.source_file = ?
            ''', (self.input_file,))
            
            questions = cursor.fetchall()
            
            # For each question, get its options
            self.cached_questions = {}
            self.skipped_questions = set()  # Initialize skipped questions set
            
            for q in questions:
                cursor.execute('''
                SELECT letter, text FROM options WHERE question_id = ?
                ''', (q['id'],))
                
                options = [{'letter': row['letter'], 'text': row['text']} for row in cursor.fetchall()]
                
                # Store skipped questions in a separate set
                if q['status'] == 'skipped':
                    question_hash = q['question_hash']
                    self.skipped_questions.add(question_hash)
                    logger.info(f"Found skipped question with hash: {question_hash[:10]}...")
                
                # Store completed questions in cache
                elif q['status'] == 'completed' and q['answer']:
                    self.cached_questions[q['question_hash']] = {
                        'question': q['question_text'],
                        'options': options,
                        'answer': q['answer'],
                        'reasoning': q['reasoning'],
                        'citations': q['citations']
                    }
                
                # Handle pending questions with answers (legacy data)
                elif q['status'] == 'pending' and q['answer']:
                    self.cached_questions[q['question_hash']] = {
                        'question': q['question_text'],
                        'options': options,
                        'answer': q['answer'],
                        'reasoning': q['reasoning'],
                        'citations': q['citations']
                    }
            
            conn.close()
            
            logger.info(f"Loaded {len(self.cached_questions)} cached completed questions and {len(self.skipped_questions)} skipped questions for {os.path.basename(self.input_file)}")
            self.update_db_stats()
        except Exception as e:
            logger.exception(f"Error loading cached questions: {str(e)}")
            self.cached_questions = {}
            self.skipped_questions = set()
            self.update_db_stats()
    
    def update_db_stats(self):
        """Update the database statistics display"""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Get total counts
            cursor.execute('SELECT COUNT(*) FROM questions')
            total_questions = cursor.fetchone()[0]
            
            cursor.execute('SELECT COUNT(*) FROM answers')
            total_answers = cursor.fetchone()[0]
            
            # Count questions by status
            cursor.execute("SELECT COUNT(*) FROM questions WHERE status='completed'")
            completed_count = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM questions WHERE status='skipped'")
            skipped_count = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM questions WHERE status='pending'")
            pending_count = cursor.fetchone()[0]
            
            # Count incomplete questions (failed due to timeout or errors)
            cursor.execute("SELECT COUNT(*) FROM questions WHERE status='incomplete'")
            incomplete_count = cursor.fetchone()[0]
            
            # Get count by source file
            cursor.execute("SELECT source_file, COUNT(*) as count FROM questions GROUP BY source_file ORDER BY count DESC LIMIT 5")
            file_counts = cursor.fetchall()
            
            # Get answer distribution
            cursor.execute("""
            SELECT answer, COUNT(*) as count 
            FROM answers 
            GROUP BY answer 
            ORDER BY count DESC
            """)
            answer_counts = cursor.fetchall()
            
            # Get most recent processed date
            cursor.execute("""
            SELECT processed_date FROM answers 
            ORDER BY processed_date DESC 
            LIMIT 1
            """)
            last_processed = cursor.fetchone()
            last_processed_date = last_processed[0] if last_processed else "Never"
            
            # Skip UI updates if the database text widget hasn't been created yet
            # This happens during initialization before the UI is fully set up
            if hasattr(self, 'db_stats_text'):
                # Format and display the stats
                self.db_stats_text.config(state=tk.NORMAL)
                self.db_stats_text.delete(1.0, tk.END)
                
                # Insert and style title
                self.db_stats_text.insert(tk.END, "Database Summary\n", "title")
                self.db_stats_text.insert(tk.END, "═════════════════\n\n", "separator")
                
                # Insert counts with tags for styling
                self.db_stats_text.insert(tk.END, "Total Questions: ", "label")
                self.db_stats_text.insert(tk.END, f"{total_questions}\n", "value")
                
                self.db_stats_text.insert(tk.END, "Total Answers: ", "label")
                self.db_stats_text.insert(tk.END, f"{total_answers}\n", "value")
                
                self.db_stats_text.insert(tk.END, "Completed Questions: ", "label")
                self.db_stats_text.insert(tk.END, f"{completed_count}\n", "value")
                
                self.db_stats_text.insert(tk.END, "Skipped Questions: ", "label")
                self.db_stats_text.insert(tk.END, f"{skipped_count}\n", "value")
                
                self.db_stats_text.insert(tk.END, "Pending Questions: ", "label")
                self.db_stats_text.insert(tk.END, f"{pending_count}\n", "value")
                
                # Add incomplete questions (failed due to timeout or errors)
                self.db_stats_text.insert(tk.END, "Incomplete Questions: ", "label")
                self.db_stats_text.insert(tk.END, f"{incomplete_count}\n", "value_highlight" if incomplete_count > 0 else "value")
                
                self.db_stats_text.insert(tk.END, "Last Processed: ", "label")
                self.db_stats_text.insert(tk.END, f"{last_processed_date}\n\n", "value")
                
                # Show completion rate percentage
                if total_questions > 0:
                    completion_rate = (completed_count / total_questions) * 100
                    self.db_stats_text.insert(tk.END, "Completion Rate: ", "label")
                    self.db_stats_text.insert(tk.END, f"{completion_rate:.1f}%\n\n", "percentage")
                
                # Top source files section
                self.db_stats_text.insert(tk.END, "Top Source Files:\n", "section")
                if file_counts:
                    for file_info in file_counts:
                        file_name = os.path.basename(file_info[0]) if file_info[0] else "Unknown"
                        file_count = file_info[1]
                        percentage = (file_count / total_questions) * 100 if total_questions > 0 else 0
                        self.db_stats_text.insert(tk.END, f"• {file_name}: ", "item")
                        self.db_stats_text.insert(tk.END, f"{file_count} questions ", "value")
                        self.db_stats_text.insert(tk.END, f"({percentage:.1f}%)\n", "percentage")
                else:
                    self.db_stats_text.insert(tk.END, "No files processed yet\n", "italic")
                
                # Section for incomplete questions if there are any
                if incomplete_count > 0:
                    self.db_stats_text.insert(tk.END, "\nIncomplete Questions By File:\n", "section_warning")
                    cursor.execute("""
                    SELECT source_file, COUNT(*) as count 
                    FROM questions 
                    WHERE status='incomplete' 
                    GROUP BY source_file 
                    ORDER BY count DESC
                    """)
                    
                    incomplete_files = cursor.fetchall()
                    for file_info in incomplete_files:
                        file_name = os.path.basename(file_info[0]) if file_info[0] else "Unknown"
                        file_count = file_info[1]
                        self.db_stats_text.insert(tk.END, f"• {file_name}: ", "item")
                        self.db_stats_text.insert(tk.END, f"{file_count} incomplete\n", "value_warning")
                
                # Answer distribution section
                if answer_counts:
                    self.db_stats_text.insert(tk.END, "\nAnswer Distribution:\n", "section")
                    for answer_info in answer_counts:
                        answer_letter = answer_info[0]
                        answer_count = answer_info[1]
                        percentage = (answer_count / total_answers) * 100 if total_answers > 0 else 0
                        self.db_stats_text.insert(tk.END, f"• Option {answer_letter}: ", "item")
                        self.db_stats_text.insert(tk.END, f"{answer_count} answers ", "value")
                        self.db_stats_text.insert(tk.END, f"({percentage:.1f}%)\n", "percentage")
                
                # Configure tag styles
                self.db_stats_text.tag_configure("title", font=("Helvetica", 12, "bold"), foreground="navy")
                self.db_stats_text.tag_configure("separator", font=("Helvetica", 10))
                self.db_stats_text.tag_configure("label", font=("Helvetica", 10, "bold"))
                self.db_stats_text.tag_configure("value", font=("Helvetica", 10))
                self.db_stats_text.tag_configure("value_highlight", font=("Helvetica", 10, "bold"), foreground="orange")
                self.db_stats_text.tag_configure("value_warning", font=("Helvetica", 10), foreground="red")
                self.db_stats_text.tag_configure("percentage", font=("Helvetica", 10), foreground="blue")
                self.db_stats_text.tag_configure("section", font=("Helvetica", 11, "bold"), foreground="navy")
                self.db_stats_text.tag_configure("section_warning", font=("Helvetica", 11, "bold"), foreground="red")
                self.db_stats_text.tag_configure("item", font=("Helvetica", 10, "bold"))
                self.db_stats_text.tag_configure("italic", font=("Helvetica", 10, "italic"), foreground="gray")
                
                self.db_stats_text.config(state=tk.DISABLED)
            
            conn.close()
        except Exception as e:
            logger.exception(f"Error updating DB stats: {str(e)}")
            # Only try to update UI if the widget exists
            if hasattr(self, 'db_stats_text'):
                self.db_stats_text.config(state=tk.NORMAL)
                self.db_stats_text.delete(1.0, tk.END)
                self.db_stats_text.insert(tk.END, f"Error getting database statistics: {str(e)}")
                self.db_stats_text.config(state=tk.DISABLED)
    
    def clear_cache(self):
        """Clear the database cache"""
        if messagebox.askyesno("Confirm Clear Cache", 
                             "Are you sure you want to clear all cached questions and answers? This operation cannot be undone."):
            try:
                conn = sqlite3.connect(DB_FILE)
                cursor = conn.cursor()
                
                # Delete all data
                cursor.execute('DELETE FROM answers')
                cursor.execute('DELETE FROM options')
                cursor.execute('DELETE FROM questions')
                
                conn.commit()
                conn.close()
                
                self.cached_questions = {}
                logger.info("Database cache cleared")
                messagebox.showinfo("Cache Cleared", "All cached questions and answers have been cleared.")
                self.update_db_stats()
            except Exception as e:
                logger.exception(f"Error clearing cache: {str(e)}")
                messagebox.showerror("Error", f"Failed to clear cache: {str(e)}")
    
    def save_progress(self):
        """Save current progress to a Word document"""
        if not self.results:
            messagebox.showinfo("No Results", "There are no results to save yet.")
            return
            
        try:
            self.save_progress_button.config(state=tk.DISABLED)
            self.progress_var.set("Saving progress...")
            
            # Create the document in a separate thread
            save_thread = threading.Thread(target=self.create_output_document, 
                                         args=(False,))  # False = don't complete processing after saving
            save_thread.daemon = True
            save_thread.start()
        except Exception as e:
            logger.exception(f"Error saving progress: {str(e)}")
            self.progress_var.set(f"Error saving progress: {str(e)}")
            self.save_progress_button.config(state=tk.NORMAL)

    def save_to_database(self, result):
        """Save a processed question and answer to the database"""
        try:
            question = result['question']
            options = result['options']
            
            # Remove "Question: " prefix if present
            if question.startswith("Question: "):
                question = question[10:].strip()
            
            # Create a hash for the question+options
            question_hash = hash_question(question, options)
            
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Store in the database
            # First check if this question already exists
            cursor.execute('SELECT id FROM questions WHERE question_hash = ?', (question_hash,))
            question_id = cursor.fetchone()
            
            if question_id:
                question_id = question_id[0]
                # Update existing question to mark as completed
                cursor.execute('''
                UPDATE questions SET processed_date = ?, status = 'completed' WHERE id = ?
                ''', (time.strftime("%Y-%m-%d %H:%M:%S"), question_id))
                logger.info(f"Updated question status to completed: {question_hash[:10]}...")
            else:
                # Insert new question with completed status
                cursor.execute('''
                INSERT INTO questions (question_hash, question_text, source_file, processed_date, status)
                VALUES (?, ?, ?, ?, 'completed')
                ''', (question_hash, question, self.input_file, time.strftime("%Y-%m-%d %H:%M:%S")))
                
                question_id = cursor.lastrowid
                
                # Insert options
                for option in options:
                    cursor.execute('''
                    INSERT INTO options (question_id, letter, text)
                    VALUES (?, ?, ?)
                    ''', (question_id, option['letter'], option['text']))
            
            # Check if this question already has an answer
            cursor.execute('SELECT id FROM answers WHERE question_id = ?', (question_id,))
            answer_id = cursor.fetchone()
            
            if answer_id:
                # Update existing answer
                cursor.execute('''
                UPDATE answers 
                SET answer = ?, reasoning = ?, citations = ?, processed_date = ?
                WHERE question_id = ?
                ''', (result['answer'], result['reasoning'], result['citations'], 
                     time.strftime("%Y-%m-%d %H:%M:%S"), question_id))
            else:
                # Insert new answer
                cursor.execute('''
                INSERT INTO answers (question_id, answer, reasoning, citations, processed_date)
                VALUES (?, ?, ?, ?, ?)
                ''', (question_id, result['answer'], result['reasoning'], result['citations'], 
                     time.strftime("%Y-%m-%d %H:%M:%S")))
            
            conn.commit()
            conn.close()
            
            # Update cached questions (also using the cleaned version of the question)
            self.cached_questions[question_hash] = {
                'question': question,
                'options': options,
                'answer': result['answer'],
                'reasoning': result['reasoning'],
                'citations': result['citations']
            }
            
            # Update database stats
            self.update_db_stats()
            
            logger.info(f"Saved question and answer to database: {question[:50]}...")
        except Exception as e:
            logger.exception(f"Error saving to database: {str(e)}")

    def draw_api_indicator(self, state):
        """Draw the API activity indicator"""
        self.api_activity_indicator.delete("all")
        
        if state == "active":
            # Bright green circle for active - more visible
            self.api_activity_indicator.create_oval(2, 2, 18, 18, fill="#00E676", outline="#00C853", width=2)
            # Add a bright glow effect
            self.api_activity_indicator.create_oval(0, 0, 20, 20, outline="#69F0AE", width=1)
            # Update status text with bold font for emphasis
            self.api_status_var.set(f"API: Active ({self.active_api_requests} requests)")
            
            # Schedule a blink if we're active
            if self.active_api_requests > 0:
                self.master.after(300, lambda: self.draw_api_indicator("active_blink"))  # Faster blink rate
        elif state == "active_blink":
            # Brighter pulsing green for blink effect
            self.api_activity_indicator.create_oval(2, 2, 18, 18, fill="#69F0AE", outline="#00C853", width=2)
            # Add a bright glow effect
            self.api_activity_indicator.create_oval(0, 0, 20, 20, outline="#B9F6CA", width=1)
            # Schedule return to normal active state
            if self.active_api_requests > 0:
                self.master.after(300, lambda: self.draw_api_indicator("active"))  # Faster blink rate
        else:
            # Gray circle for idle
            self.api_activity_indicator.create_oval(2, 2, 18, 18, fill="#9E9E9E", outline="#616161")
            # Update status text
            self.api_status_var.set("API: Idle")
    
    def start_gpu_monitoring(self):
        """Start the GPU monitoring thread"""
        if hasattr(self, 'gpu_monitoring') and self.gpu_monitoring:
            # Already running
            return
        
        # Initialize the monitoring enabled variable if needed
        if not hasattr(self, 'gpu_monitoring_enabled'):
            self.gpu_monitoring_enabled = tk.BooleanVar(value=False)
            
        # Set monitoring as enabled
        self.gpu_monitoring_enabled.set(True)
        self.gpu_monitoring = True
        
        # Create a new thread to avoid blocking if the old one is hung
        self.gpu_monitor_thread = threading.Thread(target=self.gpu_monitor_worker, daemon=True)
        self.gpu_monitor_thread.start()
        logger.info("GPU monitoring started")
        
        # Schedule the first update
        self.update_gpu_chart()
    
    def stop_gpu_monitoring(self):
        """Stop the GPU monitoring thread"""
        # Initialize the monitoring enabled variable if needed
        if not hasattr(self, 'gpu_monitoring_enabled'):
            self.gpu_monitoring_enabled = tk.BooleanVar(value=False)
            
        self.gpu_monitoring_enabled.set(False)
        self.gpu_monitoring = False
        logger.info("GPU monitoring stopped")
        
        # Don't try to join the thread as it might be hung
        # Just let it die naturally when it times out
    
    def gpu_monitor_worker(self):
        """Worker thread for GPU monitoring"""
        error_count = 0
        max_errors = 3
        
        while self.gpu_monitoring:
            try:
                # Get current GPU utilization with a safety timer
                start_time = time.time()
                
                # Add a timeout mechanism to prevent hanging
                utilization = None
                
                # Run with watchdog timer
                def get_util():
                    nonlocal utilization
                    try:
                        utilization = get_gpu_utilization()
                    except Exception as e:
                        logger.error(f"Error in GPU monitoring thread: {str(e)}")
                        utilization = 0
                
                # Start utilization getter thread
                util_thread = threading.Thread(target=get_util)
                util_thread.daemon = True
                util_thread.start()
                
                # Wait with timeout
                util_thread.join(timeout=1.0)
                
                # If we timed out, use a default value
                if utilization is None:
                    logger.warning("GPU monitoring timed out, using default value")
                    utilization = 50 if error_count % 2 == 0 else 30  # Alternate values
                    error_count += 1
                else:
                    # Reset error count on success
                    error_count = 0
                
                # Add to data
                now = time.time()
                GPU_DATA['times'].append(now)
                GPU_DATA['utilization'].append(utilization)
                
                # Keep only the last max_points values
                if len(GPU_DATA['times']) > GPU_DATA['max_points']:
                    GPU_DATA['times'] = GPU_DATA['times'][-GPU_DATA['max_points']:]
                    GPU_DATA['utilization'] = GPU_DATA['utilization'][-GPU_DATA['max_points']:]
                
                # Calculate time spent and sleep only what's needed
                elapsed = time.time() - start_time
                sleep_time = max(0.1, 1.0 - elapsed)  # Ensure at least 0.1s sleep
                time.sleep(sleep_time)
                
                # If we've had too many errors, restart monitoring
                if error_count >= max_errors:
                    logger.warning(f"GPU monitoring had {error_count} errors, restarting monitoring")
                    error_count = 0
                    # Add a dummy value to show the discontinuity
                    GPU_DATA['times'].append(time.time())
                    GPU_DATA['utilization'].append(0)
                    
            except Exception as e:
                logger.error(f"Error in GPU monitoring thread: {str(e)}")
                # Sleep a bit to avoid tight loops on persistent errors
                time.sleep(1)
                error_count += 1
    
    def update_gpu_chart(self):
        """Update the GPU utilization chart"""
        if not hasattr(self, 'gpu_monitoring') or not self.gpu_monitoring:
            # If monitoring is disabled, don't schedule another update
            return
        
        try:
            # Update the plot
            x = list(range(len(GPU_DATA['utilization'])))
            y = GPU_DATA['utilization']
            
            self.line.set_data(x, y)
            
            # Adjust x-axis if needed
            if len(x) > 0:
                self.ax.set_xlim(0, max(GPU_DATA['max_points'], len(x)))
            
            # Color based on utilization - red for high, yellow for medium, green for low
            if len(y) > 0 and y[-1] > 70:
                self.line.set_color('red')
            elif len(y) > 0 and y[-1] > 30:
                self.line.set_color('orange')
            else:
                self.line.set_color('green')
                
            # Add current utilization as text
            self.ax.set_title(f"Current: {y[-1]}%" if len(y) > 0 else "No data")
            
            # Draw the plot
            self.gpu_canvas.draw()
        except Exception as e:
            logger.error(f"Error updating GPU chart: {str(e)}")
            # If we get too many errors, disable GPU monitoring
            self.error_count = getattr(self, 'error_count', 0) + 1
            if self.error_count > 5:
                logger.error("Too many errors in GPU chart updates, disabling monitoring")
                self.stop_gpu_monitoring()
                # Update UI to reflect disabled state
                if hasattr(self, 'gpu_toggle_button'):
                    self.gpu_toggle_button.config(text="Enable GPU Monitoring")
                return
        
        # Reset error count on successful update
        self.error_count = 0
        
        # Schedule next update
        self.master.after(1000, self.update_gpu_chart)

    def open_queue_manager(self):
        """Open the queue management window"""
        if not self.pending_questions:
            messagebox.showinfo("Queue Empty", "There are no questions in the queue.")
            return
            
        if self.queue_window is not None:
            # Window already open - bring to front
            self.queue_window.lift()
            return
            
        # Create a new window
        self.queue_window = tk.Toplevel(self.master)
        self.queue_window.title("Queue Manager")
        self.queue_window.geometry("1000x800")  # Increased size to accommodate new sections
        self.queue_window.transient(self.master)  # Make window modal
        
        # Add a protocol handler to update state when window is closed
        self.queue_window.protocol("WM_DELETE_WINDOW", self.on_queue_window_close)
        
        # Create a notebook for tabs
        notebook = ttk.Notebook(self.queue_window)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Tab for pending questions
        pending_tab = ttk.Frame(notebook)
        notebook.add(pending_tab, text="Pending Questions")
        
        # Tab for processed questions (with answers)
        processed_tab = ttk.Frame(notebook)
        notebook.add(processed_tab, text="Processed Questions")
        
        # Database management tab
        db_tab = ttk.Frame(notebook)
        notebook.add(db_tab, text="Database Management")
        
        # --- PENDING QUESTIONS TAB ---
        self.setup_pending_tab(pending_tab)
        
        # --- PROCESSED QUESTIONS TAB ---
        self.setup_processed_tab(processed_tab)
        
        # --- DATABASE MANAGEMENT TAB ---
        self.setup_database_tab(db_tab)
        
        # Center the window on the parent
        self.queue_window.update_idletasks()
        width = self.queue_window.winfo_width()
        height = self.queue_window.winfo_height()
        x = self.master.winfo_x() + (self.master.winfo_width() - width) // 2
        y = self.master.winfo_y() + (self.master.winfo_height() - height) // 2
        self.queue_window.geometry(f"{width}x{height}+{x}+{y}")
    
    def setup_pending_tab(self, parent):
        """Setup the pending questions tab"""
        # Create a frame for the list of questions
        list_frame = tk.Frame(parent, padx=10, pady=10)
        list_frame.pack(fill=tk.BOTH, expand=True)
        
        tk.Label(list_frame, text="Pending Questions:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
        
        # Create a listbox with scrollbar
        list_frame_scroll = tk.Frame(list_frame)
        list_frame_scroll.pack(fill=tk.BOTH, expand=True)
        
        scrollbar = tk.Scrollbar(list_frame_scroll)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.queue_listbox = tk.Listbox(list_frame_scroll, selectmode=tk.SINGLE, height=10, width=90)
        self.queue_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.queue_listbox.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=self.queue_listbox.yview)
        
        # Populate the listbox
        for i, question in enumerate(self.pending_questions):
            question_text = question['question'][:80] + "..." if len(question['question']) > 80 else question['question']
            self.queue_listbox.insert(tk.END, f"{i+1}. {question_text}")
        
        # Question Preview frame
        preview_frame = tk.Frame(parent, padx=10, pady=5)
        preview_frame.pack(fill=tk.BOTH, expand=True)
        
        tk.Label(preview_frame, text="Question Preview:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
        
        self.queue_preview = scrolledtext.ScrolledText(preview_frame, height=8, wrap=tk.WORD)
        self.queue_preview.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Options Preview frame (new section)
        options_frame = tk.Frame(parent, padx=10, pady=5)
        options_frame.pack(fill=tk.BOTH, expand=True)
        
        tk.Label(options_frame, text="Options Preview:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
        
        self.options_preview = scrolledtext.ScrolledText(options_frame, height=8, wrap=tk.WORD)
        self.options_preview.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Button frame
        button_frame = tk.Frame(parent, padx=10, pady=10)
        button_frame.pack(fill=tk.X)
        
        # Bind selection events - mouse click and keyboard navigation
        self.queue_listbox.bind('<<ListboxSelect>>', self.on_question_select)
        
        # Add keyboard navigation
        self.queue_listbox.bind('<Up>', self.on_queue_up_key)
        self.queue_listbox.bind('<Down>', self.on_queue_down_key)
        self.queue_listbox.bind('<Return>', lambda e: self.on_question_select(None))
        
        # Ensure listbox has focus when the tab is shown
        self.queue_listbox.focus_set()
        
        # Add buttons for actions
        tk.Button(button_frame, text="Remove Selected", command=self.remove_selected_question, width=15).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Edit Selected", command=self.edit_selected_question, width=15).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Process Queue", command=self.process_queue, width=15).pack(side=tk.LEFT, padx=5)
        tk.Button(button_frame, text="Clear Queue", command=self.clear_queue, width=15).pack(side=tk.LEFT, padx=5)
    
    def on_queue_up_key(self, event):
        """Handle Up key in queue listbox"""
        try:
            # Get current selection
            current = self.queue_listbox.curselection()
            if not current:
                # If nothing selected, select the last item
                last_idx = self.queue_listbox.size() - 1
                if last_idx >= 0:
                    self.queue_listbox.selection_set(last_idx)
                    self.queue_listbox.see(last_idx)
                    self.on_question_select(None)
            elif current[0] > 0:
                # Move selection up one
                next_idx = current[0] - 1
                self.queue_listbox.selection_clear(0, tk.END)
                self.queue_listbox.selection_set(next_idx)
                self.queue_listbox.see(next_idx)
                self.on_question_select(None)
        except Exception as e:
            logger.exception(f"Error in keyboard navigation: {str(e)}")
            
    def on_queue_down_key(self, event):
        """Handle Down key in queue listbox"""
        try:
            # Get current selection
            current = self.queue_listbox.curselection()
            last_idx = self.queue_listbox.size() - 1
            
            if not current:
                # If nothing selected, select the first item
                if last_idx >= 0:
                    self.queue_listbox.selection_set(0)
                    self.queue_listbox.see(0)
                    self.on_question_select(None)
            elif current[0] < last_idx:
                # Move selection down one
                next_idx = current[0] + 1
                self.queue_listbox.selection_clear(0, tk.END)
                self.queue_listbox.selection_set(next_idx)
                self.queue_listbox.see(next_idx)
                self.on_question_select(None)
        except Exception as e:
            logger.exception(f"Error in keyboard navigation: {str(e)}")
    
    def setup_processed_tab(self, parent):
        """Setup the processed questions tab"""
        # Create a frame for the list of processed questions
        list_frame = tk.Frame(parent, padx=10, pady=10)
        list_frame.pack(fill=tk.BOTH, expand=False)
        
        tk.Label(list_frame, text="Processed Questions:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
        
        # Create a listbox with scrollbar
        list_frame_scroll = tk.Frame(list_frame)
        list_frame_scroll.pack(fill=tk.BOTH, expand=False, height=150)
        
        scrollbar = tk.Scrollbar(list_frame_scroll)
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        self.processed_listbox = tk.Listbox(list_frame_scroll, selectmode=tk.SINGLE, height=7, width=90)
        self.processed_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.processed_listbox.config(yscrollcommand=scrollbar.set)
        scrollbar.config(command=self.processed_listbox.yview)
        
        # Load processed questions from database
        self.load_processed_questions()
        
        # Create a frame to hold the details
        details_frame = tk.Frame(parent, padx=10, pady=5)
        details_frame.pack(fill=tk.BOTH, expand=True)
        
        # Create a notebook for the answer details
        details_notebook = ttk.Notebook(details_frame)
        details_notebook.pack(fill=tk.BOTH, expand=True)
        
        # Question tab
        question_tab = ttk.Frame(details_notebook)
        details_notebook.add(question_tab, text="Question & Options")
        
        # Answer tab
        answer_tab = ttk.Frame(details_notebook)
        details_notebook.add(answer_tab, text="Answer")
        
        # Reasoning tab
        reasoning_tab = ttk.Frame(details_notebook)
        details_notebook.add(reasoning_tab, text="Reasoning")
        
        # Citations tab
        citations_tab = ttk.Frame(details_notebook)
        details_notebook.add(citations_tab, text="Citations")
        
        # Setup each tab
        # Question tab
        tk.Label(question_tab, text="Question:", font=("Helvetica", 11, "bold")).pack(anchor=tk.W, padx=5, pady=5)
        self.processed_question = scrolledtext.ScrolledText(question_tab, height=6, wrap=tk.WORD)
        self.processed_question.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        tk.Label(question_tab, text="Options:", font=("Helvetica", 11, "bold")).pack(anchor=tk.W, padx=5, pady=5)
        self.processed_options = scrolledtext.ScrolledText(question_tab, height=8, wrap=tk.WORD)
        self.processed_options.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Answer tab
        tk.Label(answer_tab, text="Correct Answer:", font=("Helvetica", 11, "bold")).pack(anchor=tk.W, padx=5, pady=5)
        self.processed_answer = scrolledtext.ScrolledText(answer_tab, height=15, wrap=tk.WORD)
        self.processed_answer.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Reasoning tab
        tk.Label(reasoning_tab, text="Reasoning:", font=("Helvetica", 11, "bold")).pack(anchor=tk.W, padx=5, pady=5)
        self.processed_reasoning = scrolledtext.ScrolledText(reasoning_tab, height=15, wrap=tk.WORD)
        self.processed_reasoning.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Citations tab
        tk.Label(citations_tab, text="Citations:", font=("Helvetica", 11, "bold")).pack(anchor=tk.W, padx=5, pady=5)
        self.processed_citations = scrolledtext.ScrolledText(citations_tab, height=15, wrap=tk.WORD)
        self.processed_citations.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Button frame
        button_frame = tk.Frame(parent, padx=10, pady=10)
        button_frame.pack(fill=tk.X)
        
        # Bind selection event
        self.processed_listbox.bind('<<ListboxSelect>>', self.on_processed_question_select)
        
        # Add refresh button
        tk.Button(button_frame, text="Refresh List", command=self.load_processed_questions, width=15).pack(side=tk.LEFT, padx=5)
    
    def setup_database_tab(self, parent):
        """Setup the database management tab"""
        # Create a frame for database operations
        db_frame = tk.Frame(parent, padx=10, pady=10)
        db_frame.pack(fill=tk.BOTH, expand=True)
        
        # Database statistics section
        stats_frame = tk.LabelFrame(db_frame, text="Database Statistics", padx=10, pady=10)
        stats_frame.pack(fill=tk.X, pady=10)
        
        # Display database stats with increased height
        self.db_stats_text = scrolledtext.ScrolledText(stats_frame, height=12, wrap=tk.WORD)
        self.db_stats_text.pack(fill=tk.X, expand=False, padx=5, pady=5)
        self.update_db_stats_display()
        
        # Database operations section
        ops_frame = tk.LabelFrame(db_frame, text="Database Operations", padx=10, pady=10)
        ops_frame.pack(fill=tk.X, pady=10)
        
        # Export button with explanation
        export_frame = tk.Frame(ops_frame)
        export_frame.pack(fill=tk.X, pady=5)
        tk.Button(export_frame, text="Export Database", command=self.export_database, width=20).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Label(export_frame, text="Export the entire database to a file for backup or transfer").pack(side=tk.LEFT, padx=5, pady=5)
        
        # Import button with explanation
        import_frame = tk.Frame(ops_frame)
        import_frame.pack(fill=tk.X, pady=5)
        tk.Button(import_frame, text="Import Database", command=self.import_database, width=20).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Label(import_frame, text="Import a previously exported database file (merges with existing data)").pack(side=tk.LEFT, padx=5, pady=5)
        
        # Refresh button with explanation
        refresh_frame = tk.Frame(ops_frame)
        refresh_frame.pack(fill=tk.X, pady=5)
        tk.Button(refresh_frame, text="Refresh Statistics", command=self.update_db_stats_display, width=20).pack(side=tk.LEFT, padx=5, pady=5)
        tk.Label(refresh_frame, text="Update the database statistics display with current information").pack(side=tk.LEFT, padx=5, pady=5)
        
        # Clear cache button with explanation
        clear_frame = tk.Frame(ops_frame)
        clear_frame.pack(fill=tk.X, pady=5)
        tk.Button(clear_frame, text="Clear Database", command=self.clear_cache_confirm, width=20, bg="#ffdddd").pack(side=tk.LEFT, padx=5, pady=5)
        tk.Label(clear_frame, text="WARNING: Permanently deletes all stored questions and answers").pack(side=tk.LEFT, padx=5, pady=5)
    
    def load_processed_questions(self):
        """Load processed questions from the database"""
        try:
            # Clear the listbox
            self.processed_listbox.delete(0, tk.END)
            
            # Connect to database
            conn = sqlite3.connect(DB_FILE)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Get processed questions with answers
            cursor.execute('''
            SELECT q.id, q.question_text, q.source_file, a.answer 
            FROM questions q
            JOIN answers a ON q.id = a.question_id
            WHERE q.status = 'completed'
            ORDER BY q.id DESC
            LIMIT 100
            ''')
            
            rows = cursor.fetchall()
            
            # Store the question IDs for later use
            self.processed_question_data = []
            
            # Add to listbox
            for row in rows:
                question_text = row['question_text'][:50] + "..." if len(row['question_text']) > 50 else row['question_text']
                file_name = os.path.basename(row['source_file']) if row['source_file'] else "Unknown"
                # Display the answer along with the question
                display_text = f"{question_text} [Answer: {row['answer']}] - {file_name}"
                self.processed_listbox.insert(tk.END, display_text)
                self.processed_question_data.append(row['id'])
            
            conn.close()
        except Exception as e:
            logger.exception(f"Error loading processed questions: {str(e)}")
    
    def on_processed_question_select(self, event):
        """Handle selection of a processed question"""
        try:
            selection = self.processed_listbox.curselection()
            if selection and hasattr(self, 'processed_question_data'):
                index = selection[0]
                if index < len(self.processed_question_data):
                    question_id = self.processed_question_data[index]
                    self.display_question_details(question_id)
        except Exception as e:
            logger.exception(f"Error in processed question selection: {str(e)}")
    
    def display_question_details(self, question_id):
        """Display details of a processed question"""
        try:
            conn = sqlite3.connect(DB_FILE)
            conn.row_factory = sqlite3.Row
            cursor = conn.cursor()
            
            # Get question info
            cursor.execute('''
            SELECT q.question_text, q.source_file, a.answer, a.reasoning, a.citations, a.processed_date
            FROM questions q
            JOIN answers a ON q.id = a.question_id
            WHERE q.id = ?
            ''', (question_id,))
            
            question_data = cursor.fetchone()
            
            if not question_data:
                return
            
            # Get options
            cursor.execute('''
            SELECT letter, text FROM options WHERE question_id = ? ORDER BY letter
            ''', (question_id,))
            
            options = cursor.fetchall()
            
            # Update display
            # Question
            self.processed_question.config(state=tk.NORMAL)
            self.processed_question.delete(1.0, tk.END)
            self.processed_question.insert(tk.END, question_data['question_text'])
            # Add source file information
            file_name = os.path.basename(question_data['source_file']) if question_data['source_file'] else "Unknown"
            self.processed_question.insert(tk.END, f"\n\nSource: {file_name}")
            self.processed_question.config(state=tk.DISABLED)
            
            # Options
            self.processed_options.config(state=tk.NORMAL)
            self.processed_options.delete(1.0, tk.END)
            
            for opt in options:
                # Highlight the correct answer
                if opt['letter'] == question_data['answer']:
                    self.processed_options.insert(tk.END, f"{opt['letter']}. ", "option")
                    self.processed_options.insert(tk.END, f"{opt['text']}\n\n", "correct")
                else:
                    self.processed_options.insert(tk.END, f"{opt['letter']}. {opt['text']}\n\n", "option")
            
            # Configure tag styles
            self.processed_options.tag_configure("option", font=("Helvetica", 10))
            self.processed_options.tag_configure("correct", font=("Helvetica", 10, "bold"), foreground="green")
            
            self.processed_options.config(state=tk.DISABLED)
            
            # Answer
            self.processed_answer.config(state=tk.NORMAL)
            self.processed_answer.delete(1.0, tk.END)
            self.processed_answer.insert(tk.END, f"Selected answer: ", "label")
            self.processed_answer.insert(tk.END, f"{question_data['answer']}\n\n", "highlight")
            
            # Add processed date
            if question_data['processed_date']:
                processed_date = question_data['processed_date']
                self.processed_answer.insert(tk.END, f"Processed on: {processed_date}\n\n", "meta")
                
            # Configure answer tags
            self.processed_answer.tag_configure("label", font=("Helvetica", 10, "bold"))
            self.processed_answer.tag_configure("highlight", font=("Helvetica", 12, "bold"), foreground="blue")
            self.processed_answer.tag_configure("meta", font=("Helvetica", 9), foreground="gray")
            
            self.processed_answer.config(state=tk.DISABLED)
            
            # Reasoning
            self.processed_reasoning.config(state=tk.NORMAL)
            self.processed_reasoning.delete(1.0, tk.END)
            
            # Format the reasoning with sections
            reasoning_text = question_data['reasoning']
            
            # Apply formatting to common section patterns
            sections = [
                ("Explanation:", "section"),
                ("Analysis:", "section"),
                ("Correct Answer:", "correct_label"),
                ("Incorrect Options:", "incorrect_label")
            ]
            
            # Insert the reasoning text
            self.processed_reasoning.insert(tk.END, reasoning_text)
            
            # Apply styles to sections if found
            for section_text, tag_name in sections:
                start_idx = "1.0"
                while True:
                    start_idx = self.processed_reasoning.search(section_text, start_idx, tk.END)
                    if not start_idx:
                        break
                    
                    line_end = self.processed_reasoning.index(f"{start_idx} lineend")
                    self.processed_reasoning.tag_add(tag_name, start_idx, line_end)
                    
                    start_idx = line_end
            
            # Configure reasoning tags
            self.processed_reasoning.tag_configure("section", font=("Helvetica", 10, "bold"), foreground="navy")
            self.processed_reasoning.tag_configure("correct_label", font=("Helvetica", 10, "bold"), foreground="green")
            self.processed_reasoning.tag_configure("incorrect_label", font=("Helvetica", 10, "bold"), foreground="red")
            
            self.processed_reasoning.config(state=tk.DISABLED)
            
            # Citations
            self.processed_citations.config(state=tk.NORMAL)
            self.processed_citations.delete(1.0, tk.END)
            
            # Format citations with better styling
            if question_data['citations'] and question_data['citations'].strip():
                self.processed_citations.insert(tk.END, question_data['citations'])
                
                # Apply styling to citation elements
                self.highlight_citation_elements(self.processed_citations)
            else:
                self.processed_citations.insert(tk.END, "No citations provided for this answer.")
            
            self.processed_citations.config(state=tk.DISABLED)
            
            conn.close()
        except Exception as e:
            logger.exception(f"Error displaying question details: {str(e)}")
    
    def highlight_citation_elements(self, text_widget):
        """Apply styling to citation elements in the text widget"""
        try:
            # Highlight citation patterns like "[1]", "Reference 1:", etc.
            patterns = [
                (r'\[\d+\]', "citation_ref"),  # [1], [2], etc.
                (r'Reference \d+:', "citation_label"),  # Reference 1:, etc.
                (r'Source \d+:', "citation_label"),  # Source 1:, etc.
                (r'https?://\S+', "citation_url"),  # URLs
                (r'www\.\S+', "citation_url")  # www URLs
            ]
            
            for pattern, tag in patterns:
                start_idx = "1.0"
                while True:
                    match_idx = text_widget.search(pattern, start_idx, tk.END, regexp=True)
                    if not match_idx:
                        break
                    
                    # Find the end of the match
                    match_text = text_widget.get(match_idx, tk.END)
                    import re
                    match = re.match(pattern, match_text)
                    if not match:
                        break
                        
                    match_length = len(match.group(0))
                    end_idx = f"{match_idx}+{match_length}c"
                    
                    # Add the tag
                    text_widget.tag_add(tag, match_idx, end_idx)
                    
                    # Move to next potential match
                    start_idx = end_idx
            
            # Configure citation tags
            text_widget.tag_configure("citation_ref", font=("Helvetica", 10, "bold"), foreground="blue")
            text_widget.tag_configure("citation_label", font=("Helvetica", 10, "bold"), foreground="navy")
            text_widget.tag_configure("citation_url", font=("Helvetica", 10, "underline"), foreground="blue")
            
        except Exception as e:
            logger.exception(f"Error highlighting citations: {str(e)}")
    
    def update_db_stats_display(self):
        """Update the database statistics display"""
        try:
            conn = sqlite3.connect(DB_FILE)
            cursor = conn.cursor()
            
            # Get total counts
            cursor.execute('SELECT COUNT(*) FROM questions')
            total_questions = cursor.fetchone()[0]
            
            cursor.execute('SELECT COUNT(*) FROM answers')
            total_answers = cursor.fetchone()[0]
            
            # Count questions by status
            cursor.execute("SELECT COUNT(*) FROM questions WHERE status='completed'")
            completed_count = cursor.fetchone()[0]
            
            cursor.execute("SELECT COUNT(*) FROM questions WHERE status='skipped'")
            skipped_count = cursor.fetchone()[0]
            
            # Get count by source file
            cursor.execute("SELECT source_file, COUNT(*) as count FROM questions GROUP BY source_file ORDER BY count DESC LIMIT 5")
            file_counts = cursor.fetchall()
            
            # Skip UI updates if the database text widget hasn't been created yet
            if hasattr(self, 'db_stats_text'):
                # Format and display the stats
                self.db_stats_text.config(state=tk.NORMAL)
                self.db_stats_text.delete(1.0, tk.END)
                
                self.db_stats_text.insert(tk.END, f"Total Questions: {total_questions}\n")
                self.db_stats_text.insert(tk.END, f"Total Answers: {total_answers}\n")
                self.db_stats_text.insert(tk.END, f"Completed Questions: {completed_count}\n")
                self.db_stats_text.insert(tk.END, f"Skipped Questions: {skipped_count}\n\n")
                
                self.db_stats_text.insert(tk.END, "Top Source Files:\n")
                for file_info in file_counts:
                    file_name = os.path.basename(file_info[0]) if file_info[0] else "Unknown"
                    self.db_stats_text.insert(tk.END, f"- {file_name}: {file_info[1]} questions\n")
                
                self.db_stats_text.config(state=tk.DISABLED)
            
            conn.close()
        except Exception as e:
            logger.exception(f"Error updating DB stats display: {str(e)}")
            if hasattr(self, 'db_stats_text'):
                self.db_stats_text.config(state=tk.NORMAL)
                self.db_stats_text.delete(1.0, tk.END)
                self.db_stats_text.insert(tk.END, f"Error getting database statistics: {str(e)}")
                self.db_stats_text.config(state=tk.DISABLED)
    
    def export_database(self):
        """Export the database to a file"""
        try:
            # Get a filename to save to
            export_file = filedialog.asksaveasfilename(
                title="Export Database",
                defaultextension=".sqlite",
                filetypes=[("SQLite Database", "*.sqlite"), ("All Files", "*.*")],
                initialdir=os.path.expanduser("~")
            )
            
            if not export_file:
                return  # User cancelled
            
            # Show progress dialog
            progress_window = tk.Toplevel(self.queue_window)
            progress_window.title("Exporting Database")
            progress_window.geometry("400x150")
            progress_window.transient(self.queue_window)
            progress_window.grab_set()
            
            tk.Label(progress_window, text="Exporting database...", font=("Helvetica", 12)).pack(pady=10)
            
            progress = ttk.Progressbar(progress_window, mode="indeterminate")
            progress.pack(fill=tk.X, padx=20, pady=10)
            progress.start()
            
            status_var = tk.StringVar(value="Preparing to export...")
            status_label = tk.Label(progress_window, textvariable=status_var)
            status_label.pack(pady=10)
            
            # Define the export function
            def do_export():
                try:
                    # Copy the database file
                    status_var.set("Copying database...")
                    shutil.copy2(DB_FILE, export_file)
                    
                    # Get file stats for reporting
                    file_size = os.path.getsize(export_file) / (1024 * 1024)  # Size in MB
                    
                    # Connect to the exported database to get counts
                    export_conn = sqlite3.connect(export_file)
                    export_cursor = export_conn.cursor()
                    
                    export_cursor.execute('SELECT COUNT(*) FROM questions')
                    q_count = export_cursor.fetchone()[0]
                    
                    export_cursor.execute('SELECT COUNT(*) FROM answers')
                    a_count = export_cursor.fetchone()[0]
                    
                    export_conn.close()
                    
                    # Success message
                    status_var.set(f"Export complete! ({q_count} questions, {a_count} answers, {file_size:.2f}MB)")
                    progress.stop()
                    
                    # Add a close button
                    tk.Button(progress_window, text="Close", command=progress_window.destroy).pack(pady=5)
                    
                    # Log the success
                    logger.info(f"Database exported to {export_file} ({q_count} questions, {a_count} answers)")
                    
                    # Update database stats display
                    self.update_db_stats_display()
                    
                except Exception as e:
                    status_var.set(f"Export failed: {str(e)}")
                    logger.exception(f"Database export failed: {str(e)}")
                    progress.stop()
                    tk.Button(progress_window, text="Close", command=progress_window.destroy).pack(pady=5)
            
            # Run export in a thread
            threading.Thread(target=do_export, daemon=True).start()
            
        except Exception as e:
            logger.exception(f"Error in database export: {str(e)}")
            messagebox.showerror("Export Error", f"Failed to export database: {str(e)}")
    
    def import_database(self):
        """Import a database from a file"""
        try:
            # Get a filename to import from
            import_file = filedialog.askopenfilename(
                title="Import Database",
                filetypes=[("SQLite Database", "*.sqlite"), ("All Files", "*.*")],
                initialdir=os.path.expanduser("~")
            )
            
            if not import_file:
                return  # User cancelled
            
            # Confirm import with the user
            if not messagebox.askyesno("Confirm Import", 
                                     "Importing will merge the selected database with your existing database.\n\n"
                                     "This cannot be undone. Are you sure you want to proceed?"):
                return
            
            # Show progress dialog
            progress_window = tk.Toplevel(self.queue_window)
            progress_window.title("Importing Database")
            progress_window.geometry("400x150")
            progress_window.transient(self.queue_window)
            progress_window.grab_set()
            
            tk.Label(progress_window, text="Importing database...", font=("Helvetica", 12)).pack(pady=10)
            
            progress = ttk.Progressbar(progress_window, mode="indeterminate")
            progress.pack(fill=tk.X, padx=20, pady=10)
            progress.start()
            
            status_var = tk.StringVar(value="Preparing to import...")
            status_label = tk.Label(progress_window, textvariable=status_var)
            status_label.pack(pady=10)
            
            # Define the import function
            def do_import():
                try:
                    # Connect to both databases
                    status_var.set("Connecting to databases...")
                    import_conn = sqlite3.connect(import_file)
                    import_conn.row_factory = sqlite3.Row
                    import_cursor = import_conn.cursor()
                    
                    main_conn = sqlite3.connect(DB_FILE)
                    main_cursor = main_conn.cursor()
                    
                    # Get counts from import file
                    import_cursor.execute('SELECT COUNT(*) FROM questions')
                    import_q_count = import_cursor.fetchone()[0]
                    
                    # Begin the import process
                    status_var.set(f"Importing {import_q_count} questions...")
                    
                    # Start a transaction in the main database
                    main_conn.execute('BEGIN TRANSACTION')
                    
                    # Import questions
                    imported_count = 0
                    skipped_count = 0
                    
                    # Fetch all questions from import file
                    import_cursor.execute('SELECT * FROM questions')
                    questions = import_cursor.fetchall()
                    
                    for q in questions:
                        # Check if question hash exists in main database
                        main_cursor.execute('SELECT id FROM questions WHERE question_hash = ?', (q['question_hash'],))
                        existing = main_cursor.fetchone()
                        
                        if existing:
                            skipped_count += 1
                            continue  # Skip existing questions
                        
                        # Insert the new question
                        main_cursor.execute('''
                        INSERT INTO questions (question_hash, question_text, source_file, processed_date, status)
                        VALUES (?, ?, ?, ?, ?)
                        ''', (q['question_hash'], q['question_text'], q['source_file'], q['processed_date'], q['status']))
                        
                        new_question_id = main_cursor.lastrowid
                        
                        # Get options for this question
                        import_cursor.execute('SELECT * FROM options WHERE question_id = ?', (q['id'],))
                        options = import_cursor.fetchall()
                        
                        # Insert options
                        for opt in options:
                            main_cursor.execute('''
                            INSERT INTO options (question_id, letter, text)
                            VALUES (?, ?, ?)
                            ''', (new_question_id, opt['letter'], opt['text']))
                        
                        # Get answer if it exists
                        import_cursor.execute('SELECT * FROM answers WHERE question_id = ?', (q['id'],))
                        answer = import_cursor.fetchone()
                        
                        if answer:
                            main_cursor.execute('''
                            INSERT INTO answers (question_id, answer, reasoning, citations, processed_date)
                            VALUES (?, ?, ?, ?, ?)
                            ''', (new_question_id, answer['answer'], answer['reasoning'], answer['citations'], answer['processed_date']))
                        
                        imported_count += 1
                        
                        # Update status periodically
                        if imported_count % 10 == 0:
                            status_var.set(f"Imported {imported_count} of {import_q_count} questions...")
                    
                    # Commit the transaction
                    main_conn.commit()
                    
                    # Success message
                    status_var.set(f"Import complete! Added {imported_count} questions, skipped {skipped_count} duplicates.")
                    progress.stop()
                    
                    # Add a close button
                    close_button = tk.Button(progress_window, text="Close", command=progress_window.destroy)
                    close_button.pack(pady=5)
                    
                    # Log the success
                    logger.info(f"Database import complete: {imported_count} added, {skipped_count} skipped")
                    
                    # Update UI elements after import
                    self.update_db_stats_display()
                    
                    # Refresh the processed questions list if it exists
                    if hasattr(self, 'processed_listbox'):
                        self.load_processed_questions()
                    
                except Exception as e:
                    status_var.set(f"Import failed: {str(e)}")
                    logger.exception(f"Database import failed: {str(e)}")
                    progress.stop()
                    tk.Button(progress_window, text="Close", command=progress_window.destroy).pack(pady=5)
                finally:
                    # Close connections
                    if 'import_conn' in locals():
                        import_conn.close()
                    if 'main_conn' in locals():
                        main_conn.close()
            
            # Run import in a thread
            threading.Thread(target=do_import, daemon=True).start()
            
        except Exception as e:
            logger.exception(f"Error in database import: {str(e)}")
            messagebox.showerror("Import Error", f"Failed to import database: {str(e)}")
    
    def clear_cache_confirm(self):
        """Confirm and clear the database"""
        if messagebox.askyesno("Confirm Clear Database", 
                              "WARNING: This will permanently delete ALL questions and answers in the database. This cannot be undone.\n\n"
                              "It is recommended to export your database first as a backup.\n\n"
                              "Are you absolutely sure you want to proceed?",
                              icon=messagebox.WARNING):
            self.clear_cache()
            self.update_db_stats_display()
            self.load_processed_questions()

    def on_question_select(self, event):
        """Handle question selection in the queue listbox"""
        try:
            # Get the current selection, with or without an event
            if event is None:
                selection = self.queue_listbox.curselection()
            else:
                selection = event.widget.curselection()
                
            if selection:
                index = selection[0]
                question_data = self.pending_questions[index]
                
                # Update question preview
                self.queue_preview.delete('1.0', tk.END)
                self.queue_preview.insert(tk.END, f"{question_data['question']}")
                
                # Update options preview (separate section)
                self.options_preview.delete('1.0', tk.END)
                self.options_preview.insert(tk.END, "Available Options:\n\n")
                
                for option in question_data['options']:
                    self.options_preview.insert(tk.END, f"{option['letter']}. {option['text']}\n\n")
        except Exception as e:
            logger.exception(f"Error in question selection: {str(e)}")
    
    def remove_selected_question(self):
        """Remove the selected question from the queue"""
        try:
            selection = self.queue_listbox.curselection()
            if selection:
                index = selection[0]
                # Remove from pending questions
                removed = self.pending_questions.pop(index)
                logger.info(f"Removed question from queue: {removed['question'][:50]}...")
                
                # Update the listbox
                self.queue_listbox.delete(index)
                
                # Select the next item or clear preview if empty
                if self.queue_listbox.size() > 0:
                    self.queue_listbox.selection_set(min(index, self.queue_listbox.size()-1))
                    self.queue_listbox.event_generate("<<ListboxSelect>>")
                else:
                    self.queue_preview.delete('1.0', tk.END)
                    self.close_queue_window()  # Close window if queue is empty
        except Exception as e:
            logger.exception(f"Error removing question: {str(e)}")
    
    def edit_selected_question(self):
        """Edit the selected question"""
        try:
            selection = self.queue_listbox.curselection()
            if selection:
                index = selection[0]
                question_data = self.pending_questions[index]
                
                # Create edit dialog
                edit_window = tk.Toplevel(self.queue_window)
                edit_window.title("Edit Question")
                edit_window.geometry("700x500")
                edit_window.transient(self.queue_window)  # Make window modal
                
                # Question frame
                question_frame = tk.Frame(edit_window, padx=10, pady=10)
                question_frame.pack(fill=tk.X)
                
                tk.Label(question_frame, text="Question:").pack(anchor=tk.W)
                question_text = scrolledtext.ScrolledText(question_frame, height=5, wrap=tk.WORD)
                question_text.pack(fill=tk.X, padx=5, pady=5)
                question_text.insert(tk.END, question_data['question'])
                
                # Options frame
                options_frame = tk.Frame(edit_window, padx=10, pady=10)
                options_frame.pack(fill=tk.BOTH, expand=True)
                
                tk.Label(options_frame, text="Options:").pack(anchor=tk.W)
                
                option_entries = []
                for option in question_data['options']:
                    option_frame = tk.Frame(options_frame)
                    option_frame.pack(fill=tk.X, pady=2)
                    
                    letter_var = tk.StringVar(value=option['letter'])
                    letter_entry = tk.Entry(option_frame, textvariable=letter_var, width=3)
                    letter_entry.pack(side=tk.LEFT, padx=5)
                    
                    text_var = tk.StringVar(value=option['text'])
                    text_entry = tk.Entry(option_frame, textvariable=text_var, width=60)
                    text_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
                    
                    option_entries.append((letter_var, text_var))
                
                # Button frame
                button_frame = tk.Frame(edit_window, padx=10, pady=10)
                button_frame.pack(fill=tk.X)
                
                def save_edits():
                    """Save the edited question"""
                    new_question = question_text.get('1.0', tk.END).strip()
                    new_options = []
                    
                    for letter_var, text_var in option_entries:
                        new_options.append({
                            'letter': letter_var.get(),
                            'text': text_var.get()
                        })
                    
                    # Update the question
                    self.pending_questions[index]['question'] = new_question
                    self.pending_questions[index]['options'] = new_options
                    
                    # Update the listbox display
                    question_text = new_question[:80] + "..." if len(new_question) > 80 else new_question
                    self.queue_listbox.delete(index)
                    self.queue_listbox.insert(index, f"{index+1}. {question_text}")
                    self.queue_listbox.selection_set(index)
                    self.queue_listbox.event_generate("<<ListboxSelect>>")
                    
                    # Close the edit window
                    edit_window.destroy()
                
                tk.Button(button_frame, text="Save", command=save_edits, width=10).pack(side=tk.LEFT, padx=5)
                tk.Button(button_frame, text="Cancel", command=edit_window.destroy, width=10).pack(side=tk.LEFT, padx=5)
        except Exception as e:
            logger.exception(f"Error editing question: {str(e)}")
    
    def process_queue(self):
        """Process all questions in the queue"""
        if not self.pending_questions:
            messagebox.showinfo("Queue Empty", "There are no questions in the queue.")
            return
            
        if not messagebox.askyesno("Process All", 
                                 f"Process all {len(self.pending_questions)} questions in queue?\n\n"
                                 "This will send each question to the API without manual review."):
            return
            
        # Disable queue buttons during processing
        for widget in self.queue_window.winfo_children():
            if isinstance(widget, tk.Button):
                widget.config(state=tk.DISABLED)
                
        # Create a progress window
        progress_window = tk.Toplevel(self.queue_window)
        progress_window.title("Processing Queue")
        progress_window.geometry("500x300")
        progress_window.transient(self.queue_window)
        progress_window.grab_set()
        
        # Setup progress window
        tk.Label(progress_window, text="Processing Questions...", font=("Helvetica", 14, "bold")).pack(pady=10)
        
        progress_frame = tk.Frame(progress_window, padx=20, pady=10)
        progress_frame.pack(fill=tk.X)
        
        progress_var = tk.DoubleVar()
        progress_bar = ttk.Progressbar(progress_frame, variable=progress_var, maximum=100)
        progress_bar.pack(fill=tk.X, pady=5)
        
        progress_label = tk.Label(progress_frame, text="0 / 0 complete")
        progress_label.pack(pady=5)
        
        # Status text
        status_frame = tk.Frame(progress_window, padx=20, pady=10)
        status_frame.pack(fill=tk.BOTH, expand=True)
        
        status_text = scrolledtext.ScrolledText(status_frame, height=8, wrap=tk.WORD)
        status_text.pack(fill=tk.BOTH, expand=True)
        status_text.insert(tk.END, "Preparing to process questions...\n")
        
        # Cancel button
        cancel_var = tk.BooleanVar(value=False)
        cancel_button = tk.Button(progress_window, text="Cancel", 
                               command=lambda: cancel_var.set(True))
        cancel_button.pack(pady=10)
        
        # Add a flag for processing status
        is_processing = True
        
        # Process questions in a separate thread
        def sequential_processing_worker():
            nonlocal is_processing
            total = len(self.pending_questions)
            processed = 0
            results = []
            
            try:
                # Make a copy of pending questions to avoid modifying during iteration
                questions_to_process = list(self.pending_questions)
                
                # Process each question
                for idx, question in enumerate(questions_to_process):
                    # Check if cancelled
                    if cancel_var.get():
                        progress_window.after(0, lambda: status_text.insert(tk.END, "Processing cancelled.\n"))
                        is_processing = False
                        break
                    
                    # Update progress UI
                    def update_ui(idx, total, prog):
                        progress_var.set(prog)
                        progress_label.config(text=f"{idx} / {total} complete ({prog:.1f}%)")
                        status_text.insert(tk.END, f"Processing question {idx+1}...\n")
                        # Auto-scroll to the bottom
                        status_text.see(tk.END)
                        
                        # Update the queue listbox if available to show "Processing..."
                        if hasattr(self, 'queue_listbox'):
                            try:
                                item_text = self.queue_listbox.get(idx)
                                if "Processing..." not in item_text:
                                    self.queue_listbox.delete(idx)
                                    self.queue_listbox.insert(idx, f"{item_text} (Processing...)")
                                    self.queue_listbox.itemconfig(idx, {'bg': '#fff0d0'})  # Light yellow background
                            except Exception:
                                pass  # Ignore if index out of range
                        
                    progress_window.after(0, update_ui, idx, total, (idx / total) * 100)
                    
                    try:
                        # Check again if cancelled before starting API call
                        if cancel_var.get():
                            is_processing = False
                            break
                            
                        # Send to API with a polling mechanism to check cancellation
                        api_thread = threading.Thread(target=lambda: self._process_single_question(question, results, idx, status_text, progress_window, cancel_var), daemon=True)
                        api_thread.start()
                        
                        # Wait for API processing to complete or cancellation, checking cancel_var periodically
                        while api_thread.is_alive():
                            if cancel_var.get():
                                is_processing = False
                                progress_window.after(0, lambda: status_text.insert(tk.END, "Cancelling - waiting for current request to complete...\n"))
                                status_text.see(tk.END)
                            time.sleep(0.1)  # Short sleep to prevent high CPU usage
                        
                        if not is_processing:
                            break
                        
                        processed += 1
                        
                    except Exception as e:
                        # Update UI with error
                        def update_error_ui(idx, total):
                            error_msg = f"Error processing question {idx+1}: {str(e)}\n"
                            status_text.insert(tk.END, error_msg)
                            status_text.see(tk.END)
                            # Update queue listbox to show error
                            if hasattr(self, 'queue_listbox'):
                                try:
                                    orig_text = self.queue_listbox.get(idx).split(" (Processing")[0]  # Remove processing indicator
                                    self.queue_listbox.delete(idx)
                                    self.queue_listbox.insert(idx, f"{orig_text} [ERROR]")
                                    self.queue_listbox.itemconfig(idx, {'bg': '#ffe0e0'})  # Light red background
                                except Exception:
                                    pass  # Ignore if index out of range
                                
                        progress_window.after(0, update_error_ui, idx, total)
                        logger.exception(f"Error processing queue item: {str(e)}")
                        
                        # Check if cancelled after error
                        if cancel_var.get():
                            is_processing = False
                            break
                    
                # Clear the processed questions from the pending list
                for question in questions_to_process[:processed]:
                    if question in self.pending_questions:
                        self.pending_questions.remove(question)
                
                # Final update to UI
                def finish_processing():
                    if cancel_var.get():
                        status_text.insert(tk.END, f"Processing cancelled. {processed} of {total} questions processed.\n")
                    else:
                        status_text.insert(tk.END, f"Processing complete! {processed} questions processed.\n")
                    
                    # Update button states
                    cancel_button.config(text="Close", command=progress_window.destroy)
                    
                    # Enable export button if results exist
                    if results:
                        export_button = tk.Button(progress_window, text="Export Results to Word", 
                                               command=lambda: self.export_queue_results(results, progress_window))
                        export_button.pack(pady=5, before=cancel_button)
                    
                    # Re-enable queue window buttons
                    for widget in self.queue_window.winfo_children():
                        if isinstance(widget, tk.Button):
                            widget.config(state=tk.NORMAL)
                            
                progress_window.after(0, finish_processing)
                
            except Exception as e:
                # Handle unexpected errors
                def show_error(err_msg):
                    status_text.insert(tk.END, f"Error: {err_msg}\n")
                    cancel_button.config(text="Close", command=progress_window.destroy)
                    # Re-enable queue window buttons
                    for widget in self.queue_window.winfo_children():
                        if isinstance(widget, tk.Button):
                            widget.config(state=tk.NORMAL)
                
                progress_window.after(0, show_error, str(e))
                logger.exception(f"Error in queue processing: {str(e)}")
        
        # Start the processing thread
        threading.Thread(target=sequential_processing_worker, daemon=True).start()
        
    def _process_single_question(self, question, results, idx, status_text, progress_window, cancel_var):
        """Process a single question and handle the result"""
        try:
            # Send to API
            response = self.send_to_anythingllm(question)
            
            # Check if cancelled
            if cancel_var.get():
                return
                
            # Check if response is valid
            if not response:
                raise Exception("API returned no response")
            
            # Create result object
            result = {
                'question': question['question'],
                'options': question['options'],
                'file': question.get('file', ''),
                'answer': response['answer'],
                'reasoning': response['reasoning'],
                'citations': response['citations']
            }
            
            # Add to results
            results.append(result)
            
            # Save to database
            self.save_to_database(result)
            
            # Update UI with success
            def update_success_ui(idx, ans):
                status_text.insert(tk.END, f"Question {idx+1} completed. Answer: {ans}\n")
                status_text.see(tk.END)
                # Update queue listbox to show answer
                if hasattr(self, 'queue_listbox'):
                    try:
                        # Update the queue UI with the answer
                        orig_text = self.queue_listbox.get(idx).split(" (Processing")[0]  # Remove processing indicator
                        self.queue_listbox.delete(idx)
                        self.queue_listbox.insert(idx, f"{orig_text} [Answer: {ans}]")
                        self.queue_listbox.itemconfig(idx, {'bg': '#e0ffe0'})  # Light green background
                    except Exception:
                        pass  # Ignore if index out of range
                    
            progress_window.after(0, update_success_ui, idx, response['answer'])
        except Exception as e:
            logger.exception(f"Error in _process_single_question: {str(e)}")
            raise

    def export_queue_results(self, results, parent_window):
        """Export queue processing results to a Word document"""
        try:
            # Ask for save location
            output_file = filedialog.asksaveasfilename(
                title="Save Results",
                defaultextension=".docx",
                filetypes=[("Word Documents", "*.docx"), ("All Files", "*.*")],
                initialdir=os.path.expanduser("~")
            )
            
            if not output_file:
                return  # User cancelled
                
            # Create the document
            self.create_result_document(results, output_file)
            
            # Show success message
            messagebox.showinfo("Export Complete", f"Results exported to {output_file}")
            
        except Exception as e:
            logger.exception(f"Error exporting queue results: {str(e)}")
            messagebox.showerror("Export Error", f"Failed to export results: {str(e)}")
    
    def clear_pending_questions(self):
        """Safely clear the pending questions list"""
        num_questions = len(self.pending_questions)
        self.pending_questions = []
        logger.info(f"Cleared {num_questions} questions from pending queue")
    
    def clear_queue(self):
        """Clear all pending questions from the queue"""
        if messagebox.askyesno("Confirm Clear", "Are you sure you want to clear all pending questions?"):
            num_cleared = len(self.pending_questions)
            self.pending_questions = []
            logger.info(f"Cleared {num_cleared} questions from the queue")
            self.close_queue_window()
            
            # Update status
            self.progress_var.set(f"Cleared {num_cleared} questions from the queue")
    
    def test_api_connection(self):
        """Test the connection to the AnythingLLM API"""
        # Use hardcoded API key
        api_key = API_KEY
        model = self.model_var.get()
        
        # Create a simple test prompt
        test_prompt = "Please respond with 'API is working properly.'"
        
        # Prepare the API request
        headers = {
            "Content-Type": "application/json"
        }
        if api_key:
            headers["Authorization"] = f"Bearer {api_key}"
        
        # Use the actual endpoint
        api_endpoint = self.api_endpoint_var.get().strip()
        
        # Standard OpenAI-compatible request format
        data = {
            "model": model,
            "messages": [
                {"role": "system", "content": "You are a helpful assistant."},
                {"role": "user", "content": test_prompt}
            ],
            "temperature": 0.1,
            "max_tokens": 100
        }
        
        # Update status
        self.progress_var.set("Testing API connection...")
        self.test_api_button.config(state=tk.DISABLED)
        
        # Manually activate API indicator immediately to show test is running
        self.active_api_requests += 1
        self.draw_api_indicator("active")
        
        # Show a progress dialog
        progress_window = tk.Toplevel(self.master)
        progress_window.title("API Test")
        
        # Set window size
        window_width = 800
        window_height = 300
        
        # Position the window at a fixed location relative to the main window
        # Get the main window position and size
        main_x = self.master.winfo_x()
        main_y = self.master.winfo_y()
        main_width = self.master.winfo_width()
        
        # Calculate position that centers the window horizontally relative to main window
        # and positions it above the status area at the bottom
        x_position = main_x + (main_width - window_width) // 2
        y_position = main_y + 100  # Fixed position near the top of the main window
        
        # Set the geometry with explicit positioning
        progress_window.geometry(f"{window_width}x{window_height}+{x_position}+{y_position}")
        
        # Make window transient (always on top of the main window)
        progress_window.transient(self.master)
        
        # Prevent resizing
        progress_window.resizable(False, False)
        
        tk.Label(progress_window, text="Testing connection to API...", 
                font=("Helvetica", 24)).pack(pady=20)  # Doubled font size
        
        progress_bar = ttk.Progressbar(progress_window, orient=tk.HORIZONTAL, length=600, mode='indeterminate')
        progress_bar.pack(pady=20)
        progress_bar.start()
        
        result_var = tk.StringVar(value="Connecting...")
        result_label = tk.Label(progress_window, textvariable=result_var, font=("Helvetica", 20))
        result_label.pack(pady=20)
        
        def close_progress():
            if progress_window.winfo_exists():
                progress_window.destroy()
                self.test_api_button.config(state=tk.NORMAL)
                
                # Force reset the API indicator state for API test
                # Set active_api_requests to 0 since this is a standalone test
                self.active_api_requests = 0
                self.draw_api_indicator("idle")
                
                # Log for debugging
                logger.info("API test complete - indicator reset to idle state")
        
        def run_test():
            try:
                # Record start time
                start_time = time.time()
                API_REQUESTS['last_request_time'] = start_time
                
                # Send the request to the API
                response = requests.post(
                    api_endpoint,
                    headers=headers,
                    json=data,
                    timeout=10
                )
                
                # Record response time
                end_time = time.time()
                API_REQUESTS['last_response_time'] = end_time
                response_time = end_time - start_time
                
                # Process the result
                if response.status_code == 200:
                    result = response.json()
                    API_REQUESTS['successful'] += 1
                    API_REQUESTS['total_sent'] += 1
                    
                    # Check for OpenAI format response
                    if "choices" in result and len(result["choices"]) > 0:
                        content = result["choices"][0]["message"]["content"]
                        
                        # Show success with response time
                        result_var.set(f"Success! Response time: {response_time:.2f}s\n{content[:100]}")
                        progress_bar.stop()
                        
                        # Log success
                        logger.info(f"API test successful! Response time: {response_time:.2f}s")
                        logger.info(f"API response: {content[:100]}")
                        
                        # Update status
                        self.progress_var.set(f"API test successful! Response time: {response_time:.2f}s")
                        
                        # Close after 5 seconds
                        progress_window.after(5000, close_progress)
                    else:
                        # Invalid response format
                        API_REQUESTS['failed'] += 1
                        API_REQUESTS['last_error'] = "Invalid response format"
                        result_var.set("Error: Invalid response format from API")
                        progress_bar.stop()
                        logger.error("API test failed: Invalid response format")
                        self.progress_var.set("API test failed: Invalid response format")
                        progress_window.after(5000, close_progress)
                else:
                    # HTTP error
                    API_REQUESTS['failed'] += 1
                    API_REQUESTS['last_error'] = f"HTTP {response.status_code}: {response.text}"
                    result_var.set(f"Error: HTTP {response.status_code}\n{response.text[:100]}")
                    progress_bar.stop()
                    logger.error(f"API test failed: HTTP {response.status_code}: {response.text[:100]}")
                    self.progress_var.set(f"API test failed: HTTP {response.status_code}")
                    progress_window.after(5000, close_progress)
            except requests.exceptions.ConnectionError:
                # Connection error
                API_REQUESTS['failed'] += 1
                API_REQUESTS['last_error'] = "Connection error - API not accessible"
                result_var.set("Error: Could not connect to API\nCheck your API endpoint and internet connection")
                progress_bar.stop()
                logger.error("API test failed: Connection error - API not accessible")
                self.progress_var.set("API test failed: Connection error")
                progress_window.after(5000, close_progress)
            except Exception as e:
                # Other exception
                API_REQUESTS['failed'] += 1
                API_REQUESTS['last_error'] = str(e)
                result_var.set(f"Error: {str(e)}")
                progress_bar.stop()
                logger.error(f"API test failed: {str(e)}")
                self.progress_var.set(f"API test failed: {str(e)}")
                progress_window.after(5000, close_progress)
        
        # Run the test in a separate thread
        test_thread = threading.Thread(target=run_test)
        test_thread.daemon = True
        test_thread.start()
        
        # Also make sure the indicator gets reset if the window is closed manually
        progress_window.protocol("WM_DELETE_WINDOW", close_progress)

    def show_cursor_log_info(self):
        """Show information about the Cursor AI log file"""
        info_window = tk.Toplevel(self.master)
        info_window.title("Cursor AI Log Information")
        info_window.geometry("600x400")
        info_window.transient(self.master)
        
        # Add content
        tk.Label(info_window, text="Cursor AI Log Information", font=("Helvetica", 16, "bold")).pack(pady=10)
        
        tk.Label(info_window, text="Log file location:").pack(anchor=tk.W, padx=20, pady=5)
        
        # Create a frame for the path with a copy button
        path_frame = tk.Frame(info_window)
        path_frame.pack(fill=tk.X, padx=20, pady=5)
        
        path_var = tk.StringVar(value=CURSOR_LOG_FILE)
        path_entry = tk.Entry(path_frame, textvariable=path_var, width=50, readonlybackground="#f0f0f0")
        path_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        path_entry.config(state="readonly")
        
        def copy_path():
            info_window.clipboard_clear()
            info_window.clipboard_append(CURSOR_LOG_FILE)
            copy_button.config(text="Copied!", bg="#8bc34a")
            info_window.after(1000, lambda: copy_button.config(text="Copy Path", bg="#e0e0e0"))
            
        copy_button = tk.Button(path_frame, text="Copy Path", command=copy_path, bg="#e0e0e0")
        copy_button.pack(side=tk.RIGHT, padx=5)
        
        # Add information about the log format
        tk.Label(info_window, text="Log Format Information:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W, padx=20, pady=10)
        
        info_text = scrolledtext.ScrolledText(info_window, height=10, wrap=tk.WORD)
        info_text.pack(fill=tk.BOTH, expand=True, padx=20, pady=5)
        info_text.insert(tk.END, """The Cursor AI log file contains detailed information about the application's activities in JSON format. Each log entry includes:

- timestamp: When the event occurred
- level: Logging level (INFO, WARNING, etc.)
- type: Event type (app_start, processing_start, api_request_start, etc.)
- message: Human-readable description of the event
- data: Additional structured data about the event

This format allows Cursor AI to track and analyze the application's progress and performance.
""")
        info_text.config(state="disabled")
        
        # Add a button to open the log file
        def open_log_file():
            try:
                if platform.system() == "Darwin":  # macOS
                    subprocess.run(["open", CURSOR_LOG_FILE])
                elif platform.system() == "Windows":
                    subprocess.run(["start", CURSOR_LOG_FILE], shell=True)
                else:  # Linux
                    subprocess.run(["xdg-open", CURSOR_LOG_FILE])
            except Exception as e:
                messagebox.showerror("Error", f"Could not open log file: {str(e)}")
        
        button_frame = tk.Frame(info_window)
        button_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Button(button_frame, text="Open Log File", command=open_log_file).pack(side=tk.LEFT)
        tk.Button(button_frame, text="Close", command=info_window.destroy).pack(side=tk.RIGHT)
        
        # Center the window on the parent
        info_window.update_idletasks()
        width = info_window.winfo_width()
        height = info_window.winfo_height()
        x = self.master.winfo_x() + (self.master.winfo_width() - width) // 2
        y = self.master.winfo_y() + (self.master.winfo_height() - height) // 2
        info_window.geometry(f"{width}x{height}+{x}+{y}")
        
        # Make dialog modal
        info_window.grab_set()

    def create_result_document(self, results, output_path):
        """
        Create a new Word document with the results
        """
        logger.info(f"Creating output document: {output_path}")
        doc = Document()
        
        # Add a title
        title = doc.add_heading('Question Analysis Results', 0)
        title.alignment = WD_ALIGN_PARAGRAPH.CENTER
        
        # Add a timestamp and version info
        doc.add_paragraph(f'Generated on: {time.strftime("%Y-%m-%d %H:%M:%S")} with LMS Batch Word Processor v{VERSION}')
        doc.add_paragraph('')  # Add some space
        
        # Add each question and its results
        for i, result in enumerate(results):
            # Add question number
            doc.add_heading(f'Question {i+1}', level=1)
            
            # Add the question - removed "Question: " prefix as questions are already numbered
            question_para = doc.add_paragraph()
            question_para.add_run(result['question'])
            
            # Add options - removed extra paragraph space after "Options:"
            options_para = doc.add_paragraph()
            options_para.add_run('Options:').bold = True
            
            for option in result['options']:
                option_para = doc.add_paragraph(style='List Bullet')
                option_run = option_para.add_run(f"{option['letter']}. {option['text']}")
                
                # Only make correct answer bold, no green coloring
                if option['letter'] == result['answer']:
                    option_run.bold = True
            
            # Add page break before the answer
            doc.add_page_break()
            
            # Add the answer - removed green coloring
            answer_para = doc.add_paragraph()
            answer_para.add_run('Correct Answer: ').bold = True
            answer_run = answer_para.add_run(result['answer'])
            answer_run.bold = True
            
            # Add reasoning
            reasoning_para = doc.add_paragraph()
            reasoning_para.add_run('Reasoning: ').bold = True
            reasoning_para.add_run(result['reasoning'])
            
            # Add citations
            citations_para = doc.add_paragraph()
            citations_para.add_run('Citations: ').bold = True
            citations_para.add_run(result['citations'])
            
            # Removed the separator dashes
            
            # Add a page break after each question except the last one
            if i < len(results) - 1:
                doc.add_page_break()
        
        # Save the document
        doc.save(output_path)
        logger.info(f"Document saved: {output_path}")

    def test_rag_capabilities(self):
        """Test if the AnythingLLM API is properly using RAG with the loaded document"""
        # Use hardcoded API key
        api_key = API_KEY
        model = self.model_var.get()
        
        # Create a test window
        test_window = tk.Toplevel(self.master)
        test_window.title("RAG Capabilities Test")
        test_window.geometry("800x600")
        test_window.transient(self.master)
        
        # Add content
        tk.Label(test_window, text="Testing RAG Capabilities", font=("Helvetica", 16, "bold")).pack(pady=10)
        
        # Explanation
        explanation_frame = tk.Frame(test_window, padx=10, pady=10)
        explanation_frame.pack(fill=tk.X)
        
        explanation_text = """This test checks if the API is correctly using the document loaded into its knowledge base.
It will send a query asking for specific content from the loaded document.
    
If successful, the response should contain information exclusively from the loaded document.
If unsuccessful, the model might use its general knowledge instead."""
        
        tk.Label(explanation_frame, text=explanation_text, justify=tk.LEFT, wraplength=700).pack(pady=10)
        
        # Progress bar
        progress_frame = tk.Frame(test_window)
        progress_frame.pack(fill=tk.X, padx=20, pady=10)
        
        progress_bar = ttk.Progressbar(progress_frame, orient=tk.HORIZONTAL, length=700, mode='indeterminate')
        progress_bar.pack(pady=10)
        
        # Response area
        response_frame = tk.Frame(test_window)
        response_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=10)
        
        tk.Label(response_frame, text="Response:").pack(anchor=tk.W)
        
        response_text = scrolledtext.ScrolledText(response_frame, height=15, wrap=tk.WORD)
        response_text.pack(fill=tk.BOTH, expand=True, pady=5)
        response_text.insert(tk.END, "Waiting for test to run...")
        response_text.config(state="disabled")
        
        # Status label
        status_var = tk.StringVar(value="Ready to test")
        status_label = tk.Label(test_window, textvariable=status_var, font=("Helvetica", 10))
        status_label.pack(pady=5)
        
        # Button frame
        button_frame = tk.Frame(test_window)
        button_frame.pack(fill=tk.X, padx=20, pady=10)
        
        def update_response_text(text):
            response_text.config(state="normal")
            response_text.delete("1.0", tk.END)
            response_text.insert(tk.END, text)
            response_text.config(state="disabled")
        
        def update_status(status):
            status_var.set(status)
            test_window.update_idletasks()
        
        def show_detailed_instructions():
            """Show detailed instructions for loading documents in API"""
            instructions_window = tk.Toplevel(test_window)
            instructions_window.title("Detailed Document Loading Guide")
            instructions_window.geometry("950x750")
            instructions_window.transient(test_window)
            
            # Add content with scrollbar
            main_frame = tk.Frame(instructions_window)
            main_frame.pack(fill=tk.BOTH, expand=True, padx=20, pady=20)
            
            # Create a canvas with scrollbar
            canvas = tk.Canvas(main_frame)
            scrollbar = tk.Scrollbar(main_frame, orient="vertical", command=canvas.yview)
            scrollable_frame = tk.Frame(canvas)
            
            scrollable_frame.bind(
                "<Configure>",
                lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
            )
            
            canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
            canvas.configure(yscrollcommand=scrollbar.set)
            
            canvas.pack(side="left", fill="both", expand=True)
            scrollbar.pack(side="right", fill="y")
            
            # Title
            tk.Label(scrollable_frame, text="How to Load Documents", 
                    font=("Helvetica", 18, "bold")).pack(pady=10)
            
            # Step 1
            step_frame = tk.Frame(scrollable_frame, pady=10)
            step_frame.pack(fill=tk.X)
            
            tk.Label(step_frame, text="Step 1:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
            tk.Label(step_frame, text="Log in to your AI service", 
                   wraplength=850, justify=tk.LEFT).pack(anchor=tk.W)
            
            # Step 2
            step_frame = tk.Frame(scrollable_frame, pady=10)
            step_frame.pack(fill=tk.X)
            
            tk.Label(step_frame, text="Step 2:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
            tk.Label(step_frame, text="Create a new workspace or select an existing one for your Nokia Optical documentation", 
                   wraplength=850, justify=tk.LEFT).pack(anchor=tk.W)
            
            # Step 3
            step_frame = tk.Frame(scrollable_frame, pady=10)
            step_frame.pack(fill=tk.X)
            
            tk.Label(step_frame, text="Step 3:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
            tk.Label(step_frame, text="Click on 'Documents' in the sidebar to access the document management section", 
                   wraplength=850, justify=tk.LEFT).pack(anchor=tk.W)
            
            # Step 4
            step_frame = tk.Frame(scrollable_frame, pady=10)
            step_frame.pack(fill=tk.X)
            
            tk.Label(step_frame, text="Step 4:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
            tk.Label(step_frame, text="Click 'Upload' button and select your Nokia Optical documentation file(s)", 
                   wraplength=850, justify=tk.LEFT).pack(anchor=tk.W)
            
            # Step 5
            step_frame = tk.Frame(scrollable_frame, pady=10)
            step_frame.pack(fill=tk.X)
            
            tk.Label(step_frame, text="Step 5:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
            tk.Label(step_frame, text="Wait for your system to process and index your documents. This may take a few moments depending on the size.", 
                   wraplength=850, justify=tk.LEFT).pack(anchor=tk.W)
            
            # Step 6
            step_frame = tk.Frame(scrollable_frame, pady=10)
            step_frame.pack(fill=tk.X)
            
            tk.Label(step_frame, text="Step 6:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
            tk.Label(step_frame, text="Go to the Chat interface and ensure your workspace with the Nokia documentation is selected", 
                   wraplength=850, justify=tk.LEFT).pack(anchor=tk.W)
            
            # Step 7
            step_frame = tk.Frame(scrollable_frame, pady=10)
            step_frame.pack(fill=tk.X)
            
            tk.Label(step_frame, text="Step 7:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
            tk.Label(step_frame, text="Verify your API key is set up correctly in your account settings", 
                   wraplength=850, justify=tk.LEFT).pack(anchor=tk.W)
            
            # Step 8
            step_frame = tk.Frame(scrollable_frame, pady=10)
            step_frame.pack(fill=tk.X)
            
            tk.Label(step_frame, text="Step 8:", font=("Helvetica", 12, "bold")).pack(anchor=tk.W)
            tk.Label(step_frame, text="Make sure you've entered the correct API key in this application (it should be the key displayed in your account settings)", 
                   wraplength=850, justify=tk.LEFT).pack(anchor=tk.W)
            
            # Common issues section
            issue_frame = tk.Frame(scrollable_frame, pady=20)
            issue_frame.pack(fill=tk.X)
            
            tk.Label(issue_frame, text="Common Issues & Troubleshooting:", 
                    font=("Helvetica", 14, "bold")).pack(anchor=tk.W, pady=10)
            
            issues_text = """
• Invalid API Key: Make sure your API key is correctly copied from your account.

• "Nokia Optical documentation not detected" error: Make sure the document is properly uploaded and indexed in your workspace.

• Workspace selection: Ensure you're using the correct workspace that contains the Nokia documentation.

• Slow indexing: Large documents may take longer to process. Be patient during the initial indexing.

• API connection issues: Verify your internet connection and that the API service is not experiencing downtime.

• File format issues: If your document isn't being properly indexed, try converting it to a different format (e.g., PDF to TXT).

• Check document size limits: Make sure your documents don't exceed size limits.
"""
            tk.Label(issue_frame, text=issues_text, justify=tk.LEFT, wraplength=850).pack(anchor=tk.W)
            
            # Close button
            button_frame = tk.Frame(scrollable_frame, pady=10)
            button_frame.pack(fill=tk.X)
            
            tk.Button(button_frame, text="Close Guide", 
                     command=instructions_window.destroy, 
                     width=15, font=("Helvetica", 10, "bold")).pack(pady=10)
            
            # Make the window modal
            instructions_window.grab_set()
            
            # Center the window
            instructions_window.update_idletasks()
            x = test_window.winfo_x() + (test_window.winfo_width() - instructions_window.winfo_width()) // 2
            y = test_window.winfo_y() + (test_window.winfo_height() - instructions_window.winfo_height()) // 2
            instructions_window.geometry(f"+{max(0, x)}+{max(0, y)}")
        
        def run_test():
            # Disable run button
            run_button.config(state=tk.DISABLED)
            update_status("Running test...")
            progress_bar.start()
            
            # Create the test prompt
            test_prompt = """
I need to verify that you're correctly using the Nokia Optical documentation loaded in your knowledge base.

Please provide the following information ONLY from the Nokia Optical documentation:
1. What is the title or main topic of the Nokia Optical documentation?
2. List 3-5 key concepts or terms mentioned in the Nokia Optical documentation
3. Provide a short direct quote from a specific section of the Nokia Optical documentation (with location reference)

IMPORTANT: Base your answer ONLY on the Nokia Optical documentation loaded in your knowledge base.
If you cannot access the Nokia Optical documentation, please explicitly state "Nokia Optical documentation not detected in knowledge base".

Format your response in this structure:
DOCUMENT TITLE: [title or main topic of Nokia Optical documentation]
KEY CONCEPTS: [list of 3-5 concepts/terms from Nokia Optical documentation]
SAMPLE QUOTE: [direct quote from the Nokia Optical documentation]
LOCATION: [section/page/paragraph reference in Nokia Optical documentation]
            """
            
            # Prepare the request
            headers = {
                "Content-Type": "application/json"
            }
            if api_key:
                headers["Authorization"] = f"Bearer {api_key}"
            
            # Use the API endpoint from the UI
            api_endpoint = self.api_endpoint_var.get().strip()
            
            # Use OpenAI-compatible format
            data = {
                "model": model,
                "messages": [
                    {"role": "system", "content": "You are a helpful assistant that can access and retrieve information from the Nokia Optical documentation."},
                    {"role": "user", "content": test_prompt}
                ],
                "temperature": 0.1,
                "max_tokens": 2000
            }
            
            def make_request():
                try:
                    # Send the request
                    response = requests.post(
                        api_endpoint,
                        headers=headers,
                        json=data,
                        timeout=30  # Generous timeout for this test
                    )
                    
                    if response.status_code == 200:
                        result = response.json()
                        
                        # Check for OpenAI format response
                        if "choices" in result and len(result["choices"]) > 0:
                            content = result["choices"][0]["message"]["content"]
                            
                            # Analyze response for RAG indicators
                            has_document = True
                            if "not detected" in content.lower() or "not loaded" in content.lower() or "cannot access" in content.lower():
                                has_document = False
                                
                            # Update UI based on result
                            if has_document:
                                test_window.after(0, lambda: update_status("✅ Success: Nokia Optical documentation detected in knowledge base"))
                                test_window.after(0, lambda: update_response_text(content))
                            else:
                                # More helpful error message
                                error_message = (
                                    "❌ Failed: Nokia Optical documentation not detected in knowledge base\n\n"
                                    "The model responded:\n"
                                    f"{content}\n\n"
                                    "This means the document is either not loaded or not properly indexed. "
                                    "Click 'Show Detailed Guide' for step-by-step instructions on loading documents."
                                )
                                test_window.after(0, lambda: update_status("❌ Failed: Nokia Optical documentation not detected"))
                                test_window.after(0, lambda: update_response_text(error_message))
                                # Automatically show the detailed guide
                                test_window.after(1000, show_detailed_instructions)
                        else:
                            test_window.after(0, lambda: update_status("❌ Error: Invalid API response format"))
                            test_window.after(0, lambda: update_response_text("Error: Invalid API response format"))
                    else:
                        test_window.after(0, lambda: update_status(f"❌ Error: HTTP {response.status_code}"))
                        test_window.after(0, lambda: update_response_text(f"HTTP Error {response.status_code}:\n{response.text}"))
                except requests.exceptions.ConnectionError:
                    test_window.after(0, lambda: update_status("❌ Error: Cannot connect to API"))
                    test_window.after(0, lambda: update_response_text("Connection Error: Cannot connect to API.\nCheck your API endpoint and internet connection."))
                except Exception as e:
                    test_window.after(0, lambda: update_status(f"❌ Error: {str(e)}"))
                    test_window.after(0, lambda: update_response_text(f"Error: {str(e)}"))
                finally:
                    test_window.after(0, lambda: progress_bar.stop())
                    test_window.after(0, lambda: run_button.config(state=tk.NORMAL))
            
            # Run in a separate thread
            threading.Thread(target=make_request, daemon=True).start()
        
        run_button = tk.Button(button_frame, text="Run Test", command=run_test, width=15)
        run_button.pack(side=tk.LEFT, padx=5)
        
        # Add Show Guide button
        guide_button = tk.Button(button_frame, text="Show Detailed Guide", command=show_detailed_instructions, width=20)
        guide_button.pack(side=tk.LEFT, padx=5)
        
        close_button = tk.Button(button_frame, text="Close", command=test_window.destroy, width=10)
        close_button.pack(side=tk.RIGHT, padx=5)
        
        # Show help about loading documents
        help_text = """
Note: To load a document for RAG:
1. Log in to your AI service
2. Select or create a workspace for your Nokia documentation
3. Go to Documents section and upload your files
4. Wait for indexing to complete
5. Ensure your API key is correctly configured
        """
        
        help_frame = tk.Frame(test_window, padx=10, pady=10, bg="#f0f0f0")
        help_frame.pack(fill=tk.X, padx=20, pady=10)
        
        tk.Label(help_frame, text=help_text, justify=tk.LEFT, bg="#f0f0f0", wraplength=700).pack(pady=5)
        
        # Center the window
        test_window.update_idletasks()
        width = test_window.winfo_width()
        height = test_window.winfo_height()
        x = self.master.winfo_x() + (self.master.winfo_width() - width) // 2
        y = self.master.winfo_y() + (self.master.winfo_height() - height) // 2
        test_window.geometry(f"{width}x{height}+{x}+{y}")
        
        # Make window modal
        test_window.grab_set()
        test_window.focus_set()

    def update_progress_bar(self, value, message=None):
        """Update the progress bar on the main thread"""
        def update():
            self.progress_bar['value'] = value
            if message:
                self.progress_var.set(message)
            self.master.update_idletasks()  # Force UI update
        
        # Schedule on main thread
        self.master.after(0, update)

    def on_queue_window_close(self):
        """Handle the Queue Manager window being closed"""
        if self.queue_window:
            self.queue_window.destroy()
            self.queue_window = None
            # Update the main window state if needed
            if self.is_processing:
                self.manage_queue_button.config(state=tk.NORMAL)
            logger.info("Queue Manager window closed")

def main():
    root = tk.Tk()
    app = WordDocProcessor(root)
    
    # Make window fullscreen and active
    # First update to ensure window is created
    root.update_idletasks()
    
    # Get screen dimensions
    screen_width = root.winfo_screenwidth()
    screen_height = root.winfo_screenheight()
    
    # Set to fullscreen (on Mac, use zoomed state)
    if sys.platform == "darwin":  # macOS
        root.wm_attributes('-fullscreen', True)
    else:  # Windows/Linux
        root.state('zoomed')  # This works on Windows
    
    # Make window active
    root.lift()
    root.focus_force()
    
    # Log window state
    logger.info(f"Application started in fullscreen mode ({screen_width}x{screen_height})")
    
    root.mainloop()

if __name__ == "__main__":
    main()